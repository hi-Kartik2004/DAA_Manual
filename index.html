<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=cGvuclDC_Z1vE_cnVEU6AbbSeVbP9KLEGOtEJdlB_d1lS7i_PA3XmlUMpZ8fwaRH_kmCvy597kDopqFAXvpeaA);.lst-kix_1z49i8eb19sp-8>li:before{content:"\0025a0   "}.lst-kix_1z49i8eb19sp-7>li:before{content:"\0025cb   "}ul.lst-kix_1z49i8eb19sp-8{list-style-type:none}ul.lst-kix_1z49i8eb19sp-6{list-style-type:none}ul.lst-kix_1z49i8eb19sp-7{list-style-type:none}ul.lst-kix_1z49i8eb19sp-4{list-style-type:none}ul.lst-kix_1z49i8eb19sp-5{list-style-type:none}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ul.lst-kix_1z49i8eb19sp-2{list-style-type:none}ul.lst-kix_1z49i8eb19sp-3{list-style-type:none}ul.lst-kix_1z49i8eb19sp-0{list-style-type:none}.lst-kix_1z49i8eb19sp-1>li:before{content:"\0025cb   "}ul.lst-kix_1z49i8eb19sp-1{list-style-type:none}.lst-kix_1z49i8eb19sp-0>li:before{content:"\0025cf   "}.lst-kix_1z49i8eb19sp-2>li:before{content:"\0025a0   "}.lst-kix_1z49i8eb19sp-3>li:before{content:"\0025cf   "}.lst-kix_1z49i8eb19sp-5>li:before{content:"\0025a0   "}.lst-kix_1z49i8eb19sp-4>li:before{content:"\0025cb   "}.lst-kix_1z49i8eb19sp-6>li:before{content:"\0025cf   "}ol{margin:0;padding:0}table td,table th{padding:0}.c68{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#f1efee;border-top-width:0pt;border-right-width:0pt;border-left-color:#f1efee;vertical-align:top;border-right-color:#f1efee;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:517.5pt;border-top-color:#f1efee;border-bottom-style:solid}.c59{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:520.5pt;border-top-color:#000000;border-bottom-style:solid}.c64{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:513.8pt;border-top-color:#000000;border-bottom-style:solid}.c61{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:534.8pt;border-top-color:#000000;border-bottom-style:solid}.c79{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:528.8pt;border-top-color:#000000;border-bottom-style:solid}.c9{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:516.8pt;border-top-color:#000000;border-bottom-style:solid}.c107{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:516pt;border-top-color:#000000;border-bottom-style:solid}.c97{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:514.5pt;border-top-color:#000000;border-bottom-style:solid}.c11{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:518.2pt;border-top-color:#000000;border-bottom-style:solid}.c109{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:519.8pt;border-top-color:#000000;border-bottom-style:solid}.c74{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:521.2pt;border-top-color:#000000;border-bottom-style:solid}.c93{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:515.2pt;border-top-color:#000000;border-bottom-style:solid}.c76{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:525pt;border-top-color:#000000;border-bottom-style:solid}.c62{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:517.5pt;border-top-color:#000000;border-bottom-style:solid}.c84{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:531pt;border-top-color:#000000;border-bottom-style:solid}.c65{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:509.2pt;border-top-color:#000000;border-bottom-style:solid}.c45{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:488.9pt;border-top-color:#000000;border-bottom-style:solid}.c102{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:0pt;border-right-width:0pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:0pt;border-top-style:solid;background-color:#f1efee;border-left-style:solid;border-bottom-width:0pt;width:519pt;border-top-color:#000000;border-bottom-style:solid}.c14{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:65.2pt;border-top-color:#000000;border-bottom-style:solid}.c34{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:371.2pt;border-top-color:#000000;border-bottom-style:solid}.c15{-webkit-text-decoration-skip:none;color:#000000;font-weight:700;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:12pt;font-family:"Arial";font-style:normal}.c13{-webkit-text-decoration-skip:none;color:#000000;font-weight:700;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:14pt;font-family:"Arial";font-style:normal}.c24{margin-left:15pt;padding-top:0pt;padding-bottom:0pt;line-height:1.2454545454545454;orphans:2;widows:2;text-align:center;margin-right:23pt;height:11pt}.c4{-webkit-text-decoration-skip:none;color:#000000;font-weight:700;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:13pt;font-family:"Arial";font-style:normal}.c22{margin-left:36pt;padding-top:0pt;padding-left:0pt;padding-bottom:12pt;line-height:1.5;orphans:2;widows:2;text-align:left;margin-right:21.3pt}.c17{margin-left:-14.2pt;padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:21.3pt;height:11pt}.c6{margin-left:-31.5pt;padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:21.3pt}.c29{margin-left:-28.3pt;padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:center;margin-right:7.1pt}.c37{margin-left:-14.2pt;padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:center;margin-right:21.3pt}.c40{margin-left:-14.2pt;padding-top:0pt;padding-bottom:12pt;line-height:1.5;orphans:2;widows:2;text-align:left;margin-right:21.3pt}.c69{margin-left:-28.3pt;padding-top:0pt;padding-bottom:0pt;line-height:1.5300000000000002;orphans:2;widows:2;text-align:left;margin-right:-23.3pt}.c70{margin-left:-28.3pt;padding-top:0pt;padding-bottom:0pt;line-height:1.5300000000000002;orphans:2;widows:2;text-align:left;margin-right:7.1pt}.c66{margin-left:-28.3pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center;margin-right:7.1pt}.c26{margin-left:-28.3pt;padding-top:0pt;padding-bottom:0pt;line-height:1.5300000000000002;orphans:2;widows:2;text-align:center;margin-right:7.1pt}.c80{margin-left:-42.5pt;padding-top:4pt;padding-bottom:0pt;line-height:1.13;orphans:2;widows:2;text-align:center;margin-right:-7.1pt}.c73{margin-left:-28.3pt;padding-top:0pt;padding-bottom:0pt;line-height:1.2454545454545454;orphans:2;widows:2;text-align:center;margin-right:7.1pt}.c31{padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:21.3pt}.c2{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c71{padding-top:0pt;padding-bottom:12pt;line-height:1.5;orphans:2;widows:2;text-align:center;margin-right:21.3pt}.c103{margin-left:-28.3pt;padding-top:4pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:7.1pt}.c46{color:#000000;text-decoration:none;vertical-align:baseline;font-size:18pt;font-family:"Oswald";font-style:normal}.c91{padding-top:0pt;padding-bottom:12pt;line-height:1.0;text-align:center;margin-right:21.3pt}.c8{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left;height:11pt}.c19{margin-left:-27pt;padding-top:0pt;padding-bottom:0pt;line-height:1.5;text-align:left}.c104{padding-top:0pt;padding-bottom:12pt;line-height:2.0;text-align:left;margin-right:21.3pt}.c7{text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:normal}.c33{text-decoration-skip-ink:none;font-size:12pt;-webkit-text-decoration-skip:none;text-decoration:underline}.c116{padding-top:0pt;padding-bottom:0pt;line-height:1.5;text-align:left}.c16{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:center}.c36{text-decoration:none;vertical-align:baseline;font-size:7pt;font-style:normal}.c119{padding-top:5pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c5{background-color:#f1efee;font-family:"Consolas";color:#7b9726;font-weight:700}.c39{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c83{padding-top:0pt;padding-bottom:0pt;line-height:1.5;text-align:center}.c10{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c20{background-color:#f1efee;font-family:"Consolas";color:#766e6b;font-weight:700}.c38{text-decoration:none;vertical-align:baseline;font-size:16pt;font-style:normal}.c18{text-decoration:none;vertical-align:baseline;font-size:12pt;font-style:normal}.c57{text-indent:-54pt;orphans:2;widows:2;margin-right:-10.5pt}.c106{background-color:#f1efee;color:#68615e;font-weight:400;font-family:"Consolas"}.c30{margin-left:-30pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c0{background-color:#f1efee;font-family:"Consolas";color:#68615e;font-weight:700}.c1{background-color:#f1efee;font-family:"Consolas";color:#df5320;font-weight:700}.c3{background-color:#f1efee;font-family:"Consolas";color:#6666ea;font-weight:700}.c114{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c105{color:#000000;font-size:24pt;font-family:"Oswald"}.c53{text-decoration:none;vertical-align:baseline;font-style:normal}.c12{color:#000000;font-weight:400;font-family:"Arial"}.c112{color:#000000;font-size:22pt;font-family:"Oswald"}.c82{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;text-decoration:underline}.c88{vertical-align:baseline;font-size:11pt;font-style:normal}.c52{color:#000000;font-weight:400;font-family:"Oswald"}.c35{margin-left:432pt;orphans:2;widows:2}.c99{background-color:#ffffff;max-width:488.9pt;padding:42.5pt 34.5pt 34.1pt 72pt}.c42{border-spacing:0;border-collapse:collapse;margin-right:auto}.c28{background-color:#f1efee;font-family:"Consolas";color:#407ee7}.c90{color:#0e233d;font-size:20pt;font-family:"Oswald"}.c96{color:#212121;font-family:"Arial"}.c23{color:#000000;font-family:"Arial"}.c98{color:#cccccc;font-family:"Consolas"}.c41{padding:0;margin:0}.c78{color:#666666;font-size:9pt}.c86{orphans:2;widows:2}.c117{margin-left:-28.3pt;margin-right:7.1pt}.c95{font-size:7pt}.c87{font-size:2pt}.c72{margin-left:-33.8pt}.c85{text-indent:-21.8pt}.c118{vertical-align:super}.c100{font-size:11.5pt}.c55{margin-left:-32.2pt}.c60{font-size:15pt}.c44{font-size:8pt}.c49{margin-left:-14.2pt}.c108{font-size:10.5pt}.c54{margin-left:-26.2pt}.c121{height:375.8pt}.c81{margin-left:129.8pt}.c50{margin-left:-45pt}.c67{margin-left:-33pt}.c51{font-size:12pt}.c32{height:0pt}.c27{height:11pt}.c115{text-indent:-30.8pt}.c47{margin-left:-29.2pt}.c111{margin-left:-25.5pt}.c92{text-indent:9pt}.c94{margin-left:-31.5pt}.c21{font-weight:700}.c110{font-size:13pt}.c56{margin-left:-42.8pt}.c113{font-size:16pt}.c43{margin-left:-28.5pt}.c77{height:29pt}.c75{margin-left:-30.8pt}.c89{font-size:9pt}.c58{text-indent:-45pt}.c101{margin-left:-36.8pt}.c48{font-size:14pt}.c63{text-indent:-18pt}.c120{margin-left:-27.8pt}.c25{margin-left:-27pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c99 doc-content" style="margin-left: 50%; transform: translateX(-50%); width: 100%;"><div><p class="c8 c86"><span class="c7 c12"></span></p></div><p class="c80"><span class="c53 c21 c90">UNIVERSITY OF VISVESVARAYA COLLEGE OF ENGINEERING (UVCE)</span></p><p class="c73"><span class="c18 c96 c21">K R Circle, Dr Ambedkar Veedhi, Bengaluru, Karnataka 560 001</span></p><p class="c24"><span class="c18 c21 c96"></span></p><p class="c73"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 260.15px; height: 259.21px;"><img alt="" src="images/image3.png" style="width: 260.15px; height: 259.21px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span><br> </span><span class="c21 c48">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c83 c86 c117"><span class="c53 c21 c105">Laboratory Manual</span></p><p class="c66"><span class="c105 c53 c21">Design and Analysis of Algorithms</span></p><p class="c86 c117 c119"><span class="c23 c21 c38">(SUBCODE: 21CCPC402)</span></p><p class="c86 c103"><span class="c113">(4</span><span class="c113 c118">th</span><span class="c113">&nbsp;semester B.Tech)</span><span class="c7 c12"><br></span></p><p class="c103 c86"><span class="c44">&nbsp;</span><span class="c53 c12 c87">&nbsp;</span></p><p class="c26"><span class="c82 c21 c48">Submitted By:</span><span class="c23 c21 c48 c53">&nbsp;</span></p><p class="c26"><span class="c53 c23 c21 c60">Kartikeya Saini</span></p><p class="c26"><span class="c53 c23 c21 c48">U03NM21T064023</span></p><p class="c26"><span class="c53 c23 c21 c48">ISE (B-2 batch)</span></p><p class="c27 c69"><span class="c13"></span></p><p class="c70"><span class="c13">Under the Guidance of: </span></p><p class="c70"><span class="c53 c23 c21 c48">Neetha ma&rsquo;am</span></p><p class="c70 c27"><span class="c53 c23 c21 c48"></span></p><p class="c29"><span class="c53 c21 c112">DEPARTMENT OF COMPUTER SCIENCE &amp; ENGINEERING</span></p><p class="c71 c49 c27"><span class="c46 c21"></span></p><p class="c49 c71"><span class="c46 c21">Acknowledgement </span></p><p class="c31 c49"><span>I, </span><span class="c21">Kartikeya Saini</span><span>&nbsp;wish to extend my heartfelt acknowledgment to</span><span class="c21">&nbsp;Neetha ma&rsquo;am</span><span class="c7 c12">&nbsp;for her pivotal role in the creation of this lab manual. Neetha ma&rsquo;am&#39;s dedicated efforts, insightful contributions, and expert guidance have significantly elevated the quality and educational value of this resource. Her expertise in algorithm design, coupled with a meticulous review process, has been instrumental in shaping a manual that not only meets but exceeds the highest educational standards.</span></p><p class="c17"><span class="c7 c12"></span></p><p class="c31 c49"><span class="c7 c12">Neetha ma&rsquo;am&#39;s commitment to excellence has not only refined the clarity and coherence of the content but has also fostered a collaborative and enriching learning environment. I am profoundly grateful for the opportunity to work alongside such a dedicated mentor, and I am confident that her contributions will have a lasting impact on the educational experience of students engaging with this manual.</span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c31 c27 c81"><span class="c53 c23 c21 c48"></span></p><p class="c31 c81"><span class="c53 c23 c21 c48">BANGALORE UNIVERSITY </span></p><p class="c86 c49 c91"><span class="c53 c23 c21 c48">UNIVERSITY OF VISVESVARAYA COLLEGE OF ENGINEERING </span></p><p class="c37"><span>K. R.</span><span class="c21 c48">&nbsp;</span><span class="c7 c12">CIRCLE, BENGALURU &ndash; 560001 </span></p><p class="c73"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 260.15px; height: 259.21px;"><img alt="" src="images/image3.png" style="width: 260.15px; height: 259.21px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c27 c73"><span class="c7 c12"></span></p><p class="c37"><span class="c2">Department of Computer Science and Engineering </span></p><p class="c37 c27"><span class="c2"></span></p><p class="c37"><span class="c2">CERTIFICATE </span></p><p class="c31 c49"><span>This is to certify that, </span><span class="c21">Kartikeya Saini (U03NM21T064023)</span><span class="c7 c12">&nbsp;has satisfactorily completed the course of Experiments in Practical Design And Analysis Of Algorithm , prescribed by Department of CSE, Bangalore University, during the academic year 2022- 23. </span></p><p class="c17"><span class="c7 c12"></span></p><p class="c86 c49 c104"><span class="c21">Signature of the Teacher</span><span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c21">Signature of the Examiner</span><span class="c7 c12">&nbsp;</span></p><p class="c31 c49"><span class="c7 c12">_______________________ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _______________________ </span></p><p class="c17"><span class="c7 c12"></span></p><p class="c31 c49"><span class="c21">Date: </span><span class="c7 c12">_______________ </span></p><p class="c31 c49"><span class="c21">Name of the Candidate: </span><span class="c7 c12">Kartikeya Saini</span></p><p class="c31 c49"><span class="c21">Reg No.:</span><span class="c7 c12">&nbsp;U03NM21T064023</span></p><p class="c31 c49"><span class="c21">Examination Centre: </span><span class="c7 c12">UVCE </span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c71 c49 c85"><span class="c46 c21">Index</span></p><a id="t.2058478b4848640047688a5d18d16739c34de772"></a><a id="t.0"></a><table class="c42 c49"><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c114"><span class="c2">Sl.No</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c16"><span class="c2">Index</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c51 c21">Page NO</span><span class="c18 c12">.</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16 c27"><span class="c7 c23 c21"></span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">Introduction</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16 c27"><span class="c7 c12"></span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">1</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">Sort a given set of elements using Merge sort and determine the time required to sort the elements. Repeat the experiment for different values of n, the number of elements in the list to be sorted and plot graph of the time taken versus number of elements. The elements can be read from file or generated using random number generator</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">7</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">2</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">Sort a given set of elements using Quick sort and determine the time required to sort the elements. Repeat the experiment for different values of n, the number of elements in the list to be sorted and plot graph of the time taken versus number of elements. The elements can be read from a file or generated using a random number generator. </span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">11</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">3</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">Write a program to perform insert and delete operations in Binary Search Tree </span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">14</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">4</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">Print all the nodes reachable from a given starting node in a digraph using the BFS method.</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">17</span></p></td></tr><tr class="c77"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">5</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">Obtain the topological ordering of vertices in a given digraph </span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">19</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">6</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">Compute the transitive closure of a given directed graph using Warshall&rsquo;s algorithm</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">21</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">7</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">Sort a given set of elements using the Heap sort method and determine the time required to sort the elements. Repeat the experiment for different values of n, the number of elements in the list to be sorted and plot a graph of the time taken versus number of elements.</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">23</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">8</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">Search for a pattern string in a given text using Horspool String Matching algorithm.</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">26</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c21 c23">9</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">Implement 0/1 Knapsack problem using dynamic programming </span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">28</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">10</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">Find Minimum Cost Spanning Tree of a given undirected graph using Prim&rsquo;s algorithm.</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">31</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">11</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">Find Minimum Cost Spanning Tree of a given undirected graph using Kruskal&#39;s algorithm. </span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">33</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">12</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">From a given vertex in a weighted connected graph, find shortest paths to other vertices using Dijkstra&#39;s algorithm. </span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">35</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">13</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">Write a program to solve Travelling SalesPerson problem using dynamic programming approach.</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">38</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">14</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c7 c12">Implement N Queens&rsquo; problem using Backtracking.</span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">42</span></p></td></tr><tr class="c32"><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c23 c21">15</span></p></td><td class="c34" colspan="1" rowspan="1"><p class="c39"><span class="c53 c12 c89">Find a subset of a given set S={S1,S2,&hellip;,Sn} of n positive integers whose SUM is equal to a given positive integer d </span></p></td><td class="c14" colspan="1" rowspan="1"><p class="c16"><span class="c7 c12">45</span></p></td></tr></table><p class="c71 c49"><span class="c21 c46">INTRODUCTION </span></p><p class="c40"><span class="c7 c12">An algorithm is a set of steps of operations to solve a problem performing calculation, data processing, and automated reasoning tasks.It is an efficient method that can be expressed within a finite amount of time and space. Design and Analysis of Algorithms is very important for designing algorithms to solve different types of problems in the branch of computer science and information technology. </span></p><p class="c40"><span class="c21 c82">Algorithm Design</span><span class="c7 c12">&nbsp;</span></p><p class="c40"><span class="c7 c12">The important aspects of algorithm design include creating an efficient algorithm to solve a problem in an efficient way using minimum time and space. To solve a problem, different approaches can be followed. Some of them can be efficient with respect to time consumption, whereas other approaches may be memory efficient. However, one has to keep in mind that both time consumption and memory usage cannot be optimised simultaneously. If we require an algorithm to run in less time, we have to invest in more memory and if we require an algorithm to run with lesser memory, we need to have more time. </span></p><p class="c40"><span class="c82 c88 c23 c21">Characteristics of Algorithms </span></p><ul class="c41 lst-kix_1z49i8eb19sp-0 start"><li class="c22 li-bullet-0"><span class="c7 c12">The main characteristics of algorithms are as follows &ndash; </span></li><li class="c22 li-bullet-0"><span class="c7 c12">Algorithms must have a unique name </span></li><li class="c22 li-bullet-0"><span class="c7 c12">Algorithms should have explicitly defined set of inputs and outputs </span></li><li class="c22 li-bullet-0"><span class="c7 c12">Algorithms are well-ordered with unambiguous operations </span></li><li class="c22 li-bullet-0"><span class="c7 c12">Algorithms halt in a finite amount of time. </span></li><li class="c22 li-bullet-0"><span class="c7 c12">Algorithms should not run for infinity, i.e., an algorithm must end at some point. </span></li></ul><p class="c40"><span class="c82 c21">Design and Analysis of Algorithms</span><span class="c7 c12">&nbsp;</span></p><p class="c40"><span>In theoretical analysis of algorithms, it is common to estimate their complexity in the asymptotic sense, i.e., to estimate the complexity function for arbitrarily large input. The term &quot;</span><span class="c21">analysis of algorithms</span><span>&quot; was coined by Donald Knuth. Donald Knuth once said &ldquo;A person well-trained in computer science knows how to deal with algorithms: how to construct them, manipulate them, understand them, analyse them.&rdquo; Algorithm analysis is an important part of computational complexity theory, which provides theoretical estimation for the required resources of an algorithm to solve a specific computational problem. Most algorithms are designed to work with inputs of arbitrary length. Analysis of algorithms is the determination of the amount of time and space resources required to execute it. Usually, the efficiency or running time of an algorithm is stated as a function relating the input length to the number of steps, known as</span><span class="c21">&nbsp;time complexity</span><span>, or volume of memory, known as </span><span class="c21">space complexity.</span><span class="c7 c12">&nbsp;</span></p><p class="c40 c27"><span class="c82 c88 c23 c21"></span></p><p class="c40"><span class="c82 c21">The Need for Analysis</span><span class="c7 c12">&nbsp;</span></p><p class="c40"><span class="c7 c12">By considering an algorithm for a specific problem, we can begin to develop pattern recognition so that similar types of problems can be solved by the help of this algorithm. Algorithms are often quite different from one another, though the objective of these algorithms are the same. For example, we know that a set of numbers can be sorted using different algorithms. Number of comparisons performed by one algorithm may vary with others for the same input. Hence, time complexity of those algorithms may differ. At the same time, we need to calculate the memory space required by each algorithm. Analysis of an algorithm is the process of analysing the problem solving capability of the algorithm in terms of the time and size required (the size of memory for storage while implementation). However, the main concern of analysis of algorithms is the required time or performance. Generally, we perform the following types of analysis </span></p><p class="c40"><span class="c21">Worst-case</span><span class="c7 c12">&nbsp;&minus; The maximum number of steps taken on any instance of size a. </span></p><p class="c40"><span class="c21">Best-case</span><span class="c7 c12">&nbsp;&minus; The minimum number of steps taken on any instance of size a. </span></p><p class="c40"><span class="c21">Average case</span><span>&nbsp;&minus; An average number of steps taken on any instance of size a</span><span class="c7 c52">&nbsp;</span></p><p class="c37 c27"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c31 c27 c25"><span class="c7 c23 c21"></span></p><p class="c31 c27 c25"><span class="c7 c23 c21"></span></p><p class="c31 c27 c25"><span class="c7 c23 c21"></span></p><p class="c31 c27 c25"><span class="c7 c23 c21"></span></p><p class="c31 c27 c25"><span class="c7 c23 c21"></span></p><p class="c31 c27 c25"><span class="c7 c23 c21"></span></p><p class="c31 c27 c25"><span class="c7 c23 c21"></span></p><p class="c31 c27 c25"><span class="c7 c23 c21"></span></p><p class="c31 c25"><span class="c7 c23 c21">1. Sort a given set of elements using Merge sort and determine the time required to sort the elements. Repeat the experiment for different values of n, the number of elements in the list to be sorted and plot graph of the time taken versus number of elements. </span></p><p class="c31 c25"><span class="c7 c12">Merge Sort is a widely used comparison-based sorting algorithm that follows the divide-and-conquer paradigm. The algorithm divides the unsorted list into two halves recursively until each sublist consists of only one element. Then, it merges these sublists in a sorted manner. The key step is the merge operation, where two sorted sublists are combined to form a single sorted list. </span></p><p class="c31 c25"><span class="c7 c12">Merge Sort is known for its stability, meaning that the relative order of equal elements remains unchanged. It has a time complexity of O(n log n) for the worst, average, and best cases, making it efficient for large datasets. Additionally, Merge Sort is often preferred for its predictable performance and adaptability to linked lists. Despite its relatively higher space complexity due to the auxiliary arrays used during merging.</span></p><p class="c31 c27 c25"><span class="c7 c12"></span></p><p class="c31 c25"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 639.67px; height: 542.67px;"><img alt="" src="images/image6.png" style="width: 639.67px; height: 542.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c31 c27 c25"><span class="c7 c12"></span></p><p class="c31 c27 c25"><span class="c7 c12"></span></p><p class="c31 c25"><span class="c4">Program</span></p><a id="t.458078dd1a827d6b60f97861fe1d9ac31a3ffed5"></a><a id="t.1"></a><table class="c42 c72"><tr class="c32"><td class="c79" colspan="1" rowspan="1"><p class="c10"><span class="c3">import</span><span class="c0">&nbsp;java.util.Scanner;<br></span><span class="c3">import</span><span class="c0">&nbsp;java.util.Random;<br><br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">MergeSortExp</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">mergeSort</span><span class="c1">(</span><span class="c3">int</span><span class="c1">[] a, </span><span class="c3">int</span><span class="c1">&nbsp;low, </span><span class="c3">int</span><span class="c1">&nbsp;high)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;N = high - low;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(N &lt;= </span><span class="c1">1</span><span class="c0">)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;mid = low + (N / </span><span class="c1">2</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;mergeSort(a, low, mid);<br> &nbsp; &nbsp; &nbsp; &nbsp;mergeSort(a, mid, high);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">[] temp = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[N];<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;i = low, j = mid;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;k = </span><span class="c1">0</span><span class="c0">; k &lt; N; k++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(i == mid)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp[k] = a[j++];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">else</span><span class="c0">&nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(j == high)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp[k] = a[i++];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">else</span><span class="c0">&nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(a[j] &lt; a[i])<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp[k] = a[j++];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">else</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp[k] = a[i++];<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;k = </span><span class="c1">0</span><span class="c0">; k &lt; N; k++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a[low++] = temp[k];<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c1">(String[] args)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Scanner scan = </span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.in);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;i;<br> &nbsp; &nbsp; &nbsp; &nbsp;Random r = </span><span class="c3">new</span><span class="c0">&nbsp;Random();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Merge Sort\nEnter the Number of times the algorithm should Run&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;times = scan.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">double</span><span class="c0">&nbsp;totaldur = </span><span class="c1">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c0">; j &lt; times; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Random Number Generated are at POS &quot;</span><span class="c0">&nbsp;+ j + </span><span class="c5">&quot; as follows : &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">[] a = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[</span><span class="c1">10</span><span class="c0">];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(i = </span><span class="c1">0</span><span class="c0">; i &lt; </span><span class="c1">10</span><span class="c0">; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a[i] = r.nextInt(</span><span class="c1">1000</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(a[i] + </span><span class="c5">&quot; &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">long</span><span class="c0">&nbsp;StartTime = System.nanoTime();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mergeSort(a, </span><span class="c1">0</span><span class="c0">, </span><span class="c1">10</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">double</span><span class="c0">&nbsp;EndTime = System.nanoTime();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">double</span><span class="c0">&nbsp;duration = (EndTime - StartTime);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Elements after Sorting are&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(i = </span><span class="c1">0</span><span class="c0">; i &lt; </span><span class="c1">10</span><span class="c0">; i++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(a[i] + </span><span class="c5">&quot; &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;&quot;</span><span class="c7 c0">);</span></p><p class="c10"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totaldur = totaldur + duration;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;\nTotal time taken to Sort is :&quot;</span><span class="c0">&nbsp;+ totaldur + </span><span class="c5">&quot; Nano Seconds&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">double</span><span class="c0">&nbsp;miliseconds = (totaldur / </span><span class="c1">1000000</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;\nTotal time taken to Sort is :&quot;</span><span class="c0">&nbsp;+ miliseconds + </span><span class="c5">&quot;Mili Seconds&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">double</span><span class="c0">&nbsp;avg = totaldur / times;<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;The Average time Spend by the System is : &quot;</span><span class="c0">&nbsp;+ avg + </span><span class="c5">&quot; Nano Second&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">double</span><span class="c0">&nbsp;miliavg = (avg / </span><span class="c1">1000000</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;The Avergae time Spend by the System is : &quot;</span><span class="c0">&nbsp;+ miliavg + </span><span class="c5">&quot; Mili Seconds&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;scan.close();<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c31 c27 c25"><span class="c7 c23 c21"></span></p><p class="c31 c25"><span class="c15">Output</span></p><a id="t.ef3c9fb4dbef16fe572b944af82642fa0bc76fc3"></a><a id="t.2"></a><table class="c42 c67"><tr class="c32"><td class="c74" colspan="1" rowspan="1"><p class="c10"><span class="c0">Merge Sort<br>Enter the Number of times the algorithm should Run: </span><span class="c1">5</span><span class="c0"><br>Random Number Generated are at POS </span><span class="c1">0</span><span class="c0">&nbsp;as follows : <br></span><span class="c1">534</span><span class="c0">&nbsp;</span><span class="c1">861</span><span class="c0">&nbsp;</span><span class="c1">7</span><span class="c0">&nbsp;</span><span class="c1">563</span><span class="c0">&nbsp;</span><span class="c1">12</span><span class="c0">&nbsp;</span><span class="c1">937</span><span class="c0">&nbsp;</span><span class="c1">70</span><span class="c0">&nbsp;</span><span class="c1">454</span><span class="c0">&nbsp;</span><span class="c1">834</span><span class="c0">&nbsp;</span><span class="c1">551</span><span class="c0">&nbsp;<br>Elements after Sorting are<br></span><span class="c1">7</span><span class="c0">&nbsp;</span><span class="c1">12</span><span class="c0">&nbsp;</span><span class="c1">70</span><span class="c0">&nbsp;</span><span class="c1">454</span><span class="c0">&nbsp;</span><span class="c1">534</span><span class="c0">&nbsp;</span><span class="c1">551</span><span class="c0">&nbsp;</span><span class="c1">563</span><span class="c0">&nbsp;</span><span class="c1">834</span><span class="c0">&nbsp;</span><span class="c1">861</span><span class="c0">&nbsp;</span><span class="c1">937</span><span class="c0">&nbsp;<br>Random Number Generated are at POS </span><span class="c1">1</span><span class="c0">&nbsp;as follows : <br></span><span class="c1">904</span><span class="c0">&nbsp;</span><span class="c1">585</span><span class="c0">&nbsp;</span><span class="c1">782</span><span class="c0">&nbsp;</span><span class="c1">420</span><span class="c0">&nbsp;</span><span class="c1">450</span><span class="c0">&nbsp;</span><span class="c1">292</span><span class="c0">&nbsp;</span><span class="c1">889</span><span class="c0">&nbsp;</span><span class="c1">886</span><span class="c0">&nbsp;</span><span class="c1">716</span><span class="c0">&nbsp;</span><span class="c1">157</span><span class="c0"><br>Elements after Sorting are<br></span><span class="c1">157</span><span class="c0">&nbsp;</span><span class="c1">292</span><span class="c0">&nbsp;</span><span class="c1">420</span><span class="c0">&nbsp;</span><span class="c1">450</span><span class="c0">&nbsp;</span><span class="c1">585</span><span class="c0">&nbsp;</span><span class="c1">716</span><span class="c0">&nbsp;</span><span class="c1">782</span><span class="c0">&nbsp;</span><span class="c1">886</span><span class="c0">&nbsp;</span><span class="c1">889</span><span class="c0">&nbsp;</span><span class="c1">904</span><span class="c0"><br>Random Number Generated are at POS </span><span class="c1">2</span><span class="c0">&nbsp;as follows :<br></span><span class="c1">695</span><span class="c0">&nbsp;</span><span class="c1">163</span><span class="c0">&nbsp;</span><span class="c1">390</span><span class="c0">&nbsp;</span><span class="c1">543</span><span class="c0">&nbsp;</span><span class="c1">668</span><span class="c0">&nbsp;</span><span class="c1">317</span><span class="c0">&nbsp;</span><span class="c1">962</span><span class="c0">&nbsp;</span><span class="c1">852</span><span class="c0">&nbsp;</span><span class="c1">290</span><span class="c0">&nbsp;</span><span class="c1">316</span><span class="c0"><br>Elements after Sorting are<br></span><span class="c1">163</span><span class="c0">&nbsp;</span><span class="c1">290</span><span class="c0">&nbsp;</span><span class="c1">316</span><span class="c0">&nbsp;</span><span class="c1">317</span><span class="c0">&nbsp;</span><span class="c1">390</span><span class="c0">&nbsp;</span><span class="c1">543</span><span class="c0">&nbsp;</span><span class="c1">668</span><span class="c0">&nbsp;</span><span class="c1">695</span><span class="c0">&nbsp;</span><span class="c1">852</span><span class="c0">&nbsp;</span><span class="c1">962</span><span class="c0">&nbsp;<br>Random Number Generated are at POS </span><span class="c1">3</span><span class="c0">&nbsp;as follows :<br></span><span class="c1">999</span><span class="c0">&nbsp;</span><span class="c1">612</span><span class="c0">&nbsp;</span><span class="c1">96</span><span class="c0">&nbsp;</span><span class="c1">616</span><span class="c0">&nbsp;</span><span class="c1">350</span><span class="c0">&nbsp;</span><span class="c1">914</span><span class="c0">&nbsp;</span><span class="c1">308</span><span class="c0">&nbsp;</span><span class="c1">954</span><span class="c0">&nbsp;</span><span class="c1">309</span><span class="c0">&nbsp;</span><span class="c1">15</span><span class="c0"><br>Elements after Sorting are<br></span><span class="c1">15</span><span class="c0">&nbsp;</span><span class="c1">96</span><span class="c0">&nbsp;</span><span class="c1">308</span><span class="c0">&nbsp;</span><span class="c1">309</span><span class="c0">&nbsp;</span><span class="c1">350</span><span class="c0">&nbsp;</span><span class="c1">612</span><span class="c0">&nbsp;</span><span class="c1">616</span><span class="c0">&nbsp;</span><span class="c1">914</span><span class="c0">&nbsp;</span><span class="c1">954</span><span class="c0">&nbsp;</span><span class="c1">999</span><span class="c0"><br>Random Number Generated are at POS </span><span class="c1">4</span><span class="c0">&nbsp;as follows :<br></span><span class="c1">624</span><span class="c0">&nbsp;</span><span class="c1">510</span><span class="c0">&nbsp;</span><span class="c1">232</span><span class="c0">&nbsp;</span><span class="c1">742</span><span class="c0">&nbsp;</span><span class="c1">946</span><span class="c0">&nbsp;</span><span class="c1">824</span><span class="c0">&nbsp;</span><span class="c1">624</span><span class="c0">&nbsp;</span><span class="c1">459</span><span class="c0">&nbsp;</span><span class="c1">590</span><span class="c0">&nbsp;</span><span class="c1">495</span><span class="c0"><br>Elements after Sorting are<br></span><span class="c1">232</span><span class="c0">&nbsp;</span><span class="c1">459</span><span class="c0">&nbsp;</span><span class="c1">495</span><span class="c0">&nbsp;</span><span class="c1">510</span><span class="c0">&nbsp;</span><span class="c1">590</span><span class="c0">&nbsp;</span><span class="c1">624</span><span class="c0">&nbsp;</span><span class="c1">624</span><span class="c0">&nbsp;</span><span class="c1">742</span><span class="c0">&nbsp;</span><span class="c1">824</span><span class="c0">&nbsp;</span><span class="c1">946</span><span class="c0"><br><br>Total time taken to Sort is :</span><span class="c1">83700.0</span><span class="c0">&nbsp;Nano Seconds<br>Total time taken to Sort is :</span><span class="c1">0.0837</span><span class="c0">Mili Seconds<br>The Average time Spent by the System is : </span><span class="c1">16740.0</span><span class="c0">&nbsp;Nano Second<br>The Avergae time Spent by the System is : </span><span class="c1">0.01674</span><span class="c7 c0">&nbsp;Mili Seconds</span></p></td></tr></table><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c4"></span></p><p class="c31 c49"><span class="c4">Graph:</span></p><p class="c31 c49"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 469.50px; height: 353.61px;"><img alt="" src="images/image4.png" style="width: 474.16px; height: 353.61px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c31 c50 c27"><span class="c7 c12"></span></p><p class="c31 c50 c27"><span class="c2"></span></p><p class="c31 c50 c27"><span class="c2"></span></p><p class="c31 c27 c50"><span class="c2"></span></p><p class="c31 c50 c27"><span class="c2"></span></p><p class="c31 c50 c27"><span class="c2"></span></p><p class="c31 c50 c27"><span class="c2"></span></p><p class="c31 c50 c27"><span class="c2"></span></p><p class="c31 c50 c27"><span class="c2"></span></p><p class="c31 c50 c27"><span class="c2"></span></p><p class="c31 c50 c27"><span class="c2"></span></p><p class="c6"><span class="c2">2. Sort a given set of elements using Quick sort and determine the time required to sort the elements. Repeat the experiment for different values of n, the number of elements in the list to be sorted and plot graph of the time taken versus number of elements. </span></p><p class="c6"><span class="c18 c12">The elements can be read from a file or generated using a random number generator. Quicksort is the other important sorting algorithm that is based on the divide-and-conquer approach. </span></p><p class="c6"><span class="c7 c12">Unlike mergesort, which divides its input elements according to their position in the array, quicksort divides them according to their value. </span></p><p class="c27 c25 c31"><span class="c7 c12"></span></p><p class="c31 c50"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 639.67px; height: 413.33px;"><img alt="" src="images/image2.png" style="width: 639.67px; height: 413.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c31 c50 c92"><span class="c4">Program</span></p><a id="t.1809002cbd055295640d6fda0ae6e1734f40a6a7"></a><a id="t.3"></a><table class="c42 c101"><tr class="c32"><td class="c76" colspan="1" rowspan="1"><p class="c10 c58"><span class="c3">import</span><span class="c0">&nbsp;java.util.Random;<br></span><span class="c3">import</span><span class="c0">&nbsp;java.util.Scanner;<br><br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">QuickSort</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;max = </span><span class="c1">2000</span><span class="c0">;<br><br> &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;</span><span class="c28 c21">partition</span><span class="c1">(</span><span class="c3">int</span><span class="c1">[] a, </span><span class="c3">int</span><span class="c1">&nbsp;low, </span><span class="c3">int</span><span class="c1">&nbsp;high)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;p, i, j, temp;<br> &nbsp; &nbsp; &nbsp; &nbsp;p = a[low];<br> &nbsp; &nbsp; &nbsp; &nbsp;i = low + </span><span class="c1">1</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;j = high;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c0">&nbsp;(low &lt; high) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c0">&nbsp;(a[i] &lt;= p &amp;&amp; i &lt; high)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c0">&nbsp;(a[j] &gt; p)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;j--;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(i &lt; j) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp = a[i];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a[i] = a[j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a[j] = temp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;temp = a[low];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a[low] = a[j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a[j] = temp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;j;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;j;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">sort</span><span class="c1">(</span><span class="c3">int</span><span class="c1">[] a, </span><span class="c3">int</span><span class="c1">&nbsp;low, </span><span class="c3">int</span><span class="c1">&nbsp;high)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(low &lt; high) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;s = partition(a, low, high);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sort(a, low, s - </span><span class="c1">1</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sort(a, s + </span><span class="c1">1</span><span class="c0">, high);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c1">(String[] args)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Enter the array size&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">try</span><span class="c0">&nbsp;(Scanner scan = </span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.in)) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;n = scan.nextInt();<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">[] a = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[max];<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Random r = </span><span class="c3">new</span><span class="c0">&nbsp;Random();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; n; i++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a[i] = r.nextInt(</span><span class="c1">20</span><span class="c0">);<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Array before sorting&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; n; i++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(a[i] + </span><span class="c5">&quot; &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">long</span><span class="c0">&nbsp;startTime = System.nanoTime();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20">QuickSort m = new QuickSort();</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m.sort(a, </span><span class="c1">0</span><span class="c0">, n-</span><span class="c1">1</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">long</span><span class="c0">&nbsp;stopTime = System.nanoTime();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">long</span><span class="c0">&nbsp;elapseTime = (stopTime - startTime);<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;\nTime taken to sort array is:&quot;</span><span class="c0">&nbsp;+ elapseTime + </span><span class="c5">&quot;nanoseconds&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Sorted array is&quot;</span><span class="c0">);<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; n; i++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(a[i]+</span><span class="c5">&quot; &quot;</span><span class="c0">);<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;scan.close();<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br><br>}</span></p></td></tr></table><p class="c17 c115"><span class="c4"></span></p><p class="c31 c25 c63"><span class="c4">Output:</span></p><a id="t.aeea51355c34ceda455a7887febc4552c05ac215"></a><a id="t.4"></a><table class="c42 c56"><tr class="c32"><td class="c84" colspan="1" rowspan="1"><p class="c10 c58"><span class="c0">Enter &nbsp;Enter the array size<br></span><span class="c1">10</span><span class="c0"><br>Array before sorting<br></span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">5</span><span class="c0">&nbsp;</span><span class="c1">19</span><span class="c0">&nbsp;</span><span class="c1">8</span><span class="c0">&nbsp;</span><span class="c1">10</span><span class="c0">&nbsp;</span><span class="c1">2</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">12</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;<br>Time taken to sort array is:</span><span class="c1">19600 </span><span class="c0">nanoseconds<br>Sorted array is<br></span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">2</span><span class="c0">&nbsp;</span><span class="c1">5</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">8</span><span class="c0">&nbsp;</span><span class="c1">10</span><span class="c0">&nbsp;</span><span class="c1">12</span><span class="c0">&nbsp;</span><span class="c1">19</span></p></td></tr></table><p class="c17"><span class="c18 c12"></span></p><p class="c31 c27 c25"><span class="c13"></span></p><p class="c31 c25"><span class="c13">Graph:</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 427.68px; height: 320.49px;"><img alt="" src="images/image1.png" style="width: 427.68px; height: 320.49px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c31 c27 c25"><span class="c2"></span></p><p class="c31 c27 c25"><span class="c2"></span></p><p class="c31 c27 c25"><span class="c2"></span></p><p class="c31 c25"><span class="c2">3. Perform insert and delete operations in Binary Search Tree</span></p><p class="c31 c25"><span class="c7 c12">A Binary Search Tree (BST) is a hierarchical data structure where each node has at most two children: a left child with a value less than the node and a right child with a value greater than the node. This ordering property is maintained throughout the tree, making search, insert, and delete operations efficient with an average time complexity of O(log n), where n is the number of nodes. The left and right subtrees of every node are also BSTs, ensuring sorted access to the elements. These properties facilitate fast searching and manipulation of data in a self-balancing binary tree structure.</span></p><p class="c31 c27 c25"><span class="c7 c12"></span></p><a id="t.01cc698256eded5e1d23549b6ca5b1fac5c324f5"></a><a id="t.5"></a><table class="c42 c54"><tr class="c32"><td class="c97" colspan="1" rowspan="1"><p class="c10"><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">BinarySearchTree</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">Node</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;data;<br> &nbsp; &nbsp; &nbsp; &nbsp;Node left, right;<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c28 c21">Node</span><span class="c1">(</span><span class="c3">int</span><span class="c1">&nbsp;item)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;data = item;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;left = right = </span><span class="c3">null</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;Node root;<br> &nbsp; &nbsp;BinarySearchTree() {<br> &nbsp; &nbsp; &nbsp; &nbsp;root = </span><span class="c3">null</span><span class="c0">;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">insert</span><span class="c1">(</span><span class="c3">int</span><span class="c1">&nbsp;data)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;root = insertRec(root, data);<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;Node </span><span class="c28 c21">insertRec</span><span class="c1">(Node root, </span><span class="c3">int</span><span class="c1">&nbsp;data)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(root == </span><span class="c3">null</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;root = </span><span class="c3">new</span><span class="c0">&nbsp;Node(data);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;root;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(data &lt; root.data) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;root.left = insertRec(root.left, data);<br> &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c0">&nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(data &gt; root.data) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;root.right = insertRec(root.right, data);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;root;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c21 c28">delete</span><span class="c1">(</span><span class="c3">int</span><span class="c1">&nbsp;data)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;root = deleteRec(root, data);<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;Node </span><span class="c28 c21">deleteRec</span><span class="c1">(Node root, </span><span class="c3">int</span><span class="c1">&nbsp;data)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(root == </span><span class="c3">null</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;root;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(data &lt; root.data) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;root.left = deleteRec(root.left, data);<br> &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c0">&nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(data &gt; root.data) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;root.right = deleteRec(root.right, data);<br> &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(root.left == </span><span class="c3">null</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;root.right;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c0">&nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(root.right == </span><span class="c3">null</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;root.left;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;root.data = minValue(root.right);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;root.right = deleteRec(root.right, root.data);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c7 c0">&nbsp;root;<br> &nbsp; &nbsp;}</span></p><p class="c10"><span class="c0"><br> &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;</span><span class="c28 c21">minValue</span><span class="c1">(Node root)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;minValue = root.data;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c0">&nbsp;(root.left != </span><span class="c3">null</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;minValue = root.left.data;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;root = root.left;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;minValue;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">inorder</span><span class="c1">()</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;inorderRec(root);<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">inorderRec</span><span class="c1">(Node root)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(root != </span><span class="c3">null</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inorderRec(root.left);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(root.data + </span><span class="c5">&quot; &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inorderRec(root.right);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c1">(String[] args)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;BinarySearchTree tree = </span><span class="c3">new</span><span class="c0">&nbsp;BinarySearchTree();<br> &nbsp; &nbsp; &nbsp; &nbsp;tree.insert(</span><span class="c1">50</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;tree.insert(</span><span class="c1">30</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;tree.insert(</span><span class="c1">20</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;tree.insert(</span><span class="c1">40</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;tree.insert(</span><span class="c1">70</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;tree.insert(</span><span class="c1">60</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;tree.insert(</span><span class="c1">80</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Inorder traversal:&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;tree.inorder();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Delete 20:&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;tree.delete(</span><span class="c1">20</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;tree.inorder();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Delete 30:&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;tree.delete(</span><span class="c1">30</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;tree.inorder();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println();<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c17"><span class="c7 c23 c21"></span></p><p class="c31 c25"><span class="c4">Output</span></p><a id="t.1b73a42c8624b0bae7ea0f7265b825b757b61f5b"></a><a id="t.6"></a><table class="c42 c120"><tr class="c32"><td class="c107" colspan="1" rowspan="1"><p class="c10"><span class="c0">Inorder traversal:<br></span><span class="c1">20</span><span class="c0">&nbsp;</span><span class="c1">30</span><span class="c0">&nbsp;</span><span class="c1">40</span><span class="c0">&nbsp;</span><span class="c1">50</span><span class="c0">&nbsp;</span><span class="c1">60</span><span class="c0">&nbsp;</span><span class="c1">70</span><span class="c0">&nbsp;</span><span class="c1">80</span><span class="c0">&nbsp;<br>Delete </span><span class="c1">20</span><span class="c0">:<br></span><span class="c1">30</span><span class="c0">&nbsp;</span><span class="c1">40</span><span class="c0">&nbsp;</span><span class="c1">50</span><span class="c0">&nbsp;</span><span class="c1">60</span><span class="c0">&nbsp;</span><span class="c1">70</span><span class="c0">&nbsp;</span><span class="c1">80</span><span class="c0">&nbsp;<br>Delete </span><span class="c1">30</span><span class="c0">:<br></span><span class="c1">40</span><span class="c0">&nbsp;</span><span class="c1">50</span><span class="c0">&nbsp;</span><span class="c1">60</span><span class="c0">&nbsp;</span><span class="c1">70</span><span class="c0">&nbsp;</span><span class="c1">80</span></p></td></tr></table><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c7 c12"></span></p><p class="c17"><span class="c4"></span></p><p class="c17"><span class="c4"></span></p><p class="c17"><span class="c4"></span></p><p class="c17"><span class="c4"></span></p><p class="c17"><span class="c4"></span></p><p class="c17"><span class="c4"></span></p><p class="c17"><span class="c4"></span></p><p class="c31 c27 c25"><span class="c2"></span></p><p class="c31 c27 c25"><span class="c2"></span></p><p class="c31 c25"><span class="c51 c21">4. Print all the nodes reachable from a given starting node in a digraph using the BFS method.</span></p><p class="c31 c25"><span class="c7 c12">Breadth-First Search (BFS) is a graph traversal algorithm that explores vertices level by level, visiting all neighbours of a node before moving on to the next level. Starting from the initial node, BFS systematically explores all reachable nodes, employing a queue to maintain the order of exploration. It ensures the shortest path is discovered first, making it ideal for finding the shortest path in unweighted graphs. BFS is complete and guarantees optimality when searching for a solution in a graph with uniform edge costs. Its time complexity is O(V + E), where V is the number of vertices and E is the number of edges in the graph.</span></p><a id="t.875b4b8bd765889afa84be9f0c6c9c0ab0d21626"></a><a id="t.7"></a><table class="c42 c47"><tr class="c32"><td class="c62" colspan="1" rowspan="1"><p class="c10"><span class="c3">import</span><span class="c0">&nbsp;java.util.LinkedList;</span><span class="c0 c108"><br></span><span class="c3">import</span><span class="c0">&nbsp;java.util.Queue;<br></span><span class="c3">import</span><span class="c0">&nbsp;java.util.Scanner;<br><br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">BFSDirectedGraph</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c1">(String[] args)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Scanner scanner = </span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.in);<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(</span><span class="c5">&quot;Enter the number of vertices: &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;vertices = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">[][] adjacencyMatrix = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[vertices][vertices];<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Enter the adjacency matrix:&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; vertices; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c0">; j &lt; vertices; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;adjacencyMatrix[i][j] = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(</span><span class="c5">&quot;Enter the starting vertex: &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;startVertex = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;BFS traversal starting from vertex &quot;</span><span class="c0">&nbsp;+ startVertex + </span><span class="c5">&quot;:&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;bfs(adjacencyMatrix, startVertex, vertices);<br> &nbsp; &nbsp; &nbsp; &nbsp;scanner.close();<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">bfs</span><span class="c1">(</span><span class="c3">int</span><span class="c1">[][] adjacencyMatrix, </span><span class="c3">int</span><span class="c1">&nbsp;startVertex, </span><span class="c3">int</span><span class="c1">&nbsp;vertices)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">boolean</span><span class="c0">[] visited = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">boolean</span><span class="c0">[vertices];<br> &nbsp; &nbsp; &nbsp; &nbsp;Queue&lt;Integer&gt; queue = </span><span class="c3">new</span><span class="c0">&nbsp;LinkedList&lt;&gt;();<br> &nbsp; &nbsp; &nbsp; &nbsp;visited[startVertex] = </span><span class="c3">true</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;queue.add(startVertex);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c0">&nbsp;(!queue.isEmpty()) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;currentVertex = queue.poll();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(currentVertex + </span><span class="c5">&quot; &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; vertices; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(!visited[i]) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;visited[i] = </span><span class="c3">true</span><span class="c7 c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;queue.add(i);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c6 c27"><span class="c4"></span></p><p class="c6"><span class="c4">Output:</span></p><a id="t.4ce3522502e16ec6a46f949d34fe2bf0ae31bba1"></a><a id="t.8"></a><table class="c42 c67"><tr class="c32"><td class="c74" colspan="1" rowspan="1"><p class="c10"><span class="c0">Enter the number of vertices:<br></span><span class="c1">5</span><span class="c0"><br>Enter the adjacency matrix:<br></span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">5</span><span class="c0">&nbsp;</span><span class="c1">19</span><span class="c0">&nbsp;</span><span class="c1">8</span><span class="c0">&nbsp;</span><span class="c1">10</span><span class="c0">&nbsp;</span><span class="c1">2</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">12</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;<br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br></span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0"><br></span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br>Enter the starting vertex: </span><span class="c1">0</span><span class="c0"><br>BFS traversal starting from vertex </span><span class="c1">0</span><span class="c0">:<br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">2</span><span class="c0">&nbsp;</span><span class="c1">3</span><span class="c0">&nbsp;</span><span class="c1">4</span></p></td></tr></table><p class="c8"><span class="c7 c12"></span></p><p class="c8"><span class="c7 c12"></span></p><p class="c8"><span class="c7 c12"></span></p><p class="c8"><span class="c7 c12"></span></p><p class="c8"><span class="c7 c12"></span></p><p class="c8"><span class="c7 c12"></span></p><p class="c8"><span class="c7 c12"></span></p><p class="c8"><span class="c7 c12"></span></p><p class="c8"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c31 c27 c25"><span class="c7 c12"></span></p><p class="c31 c25"><span class="c51 c21">5. Obtain Topological ordering of the vertices in a given digraph</span><span class="c7 c23 c21">.</span></p><p class="c31 c25"><span class="c7 c12">Topological Sorting is an algorithm used for directed acyclic graphs (DAGs) to linearly order the vertices such that for every directed edge (u, v), vertex u comes before v in the ordering. The algorithm utilises depth-first search (DFS) to traverse the graph and assigns a topological order to each vertex. Topological sorting is applicable only to DAGs, as cyclic dependencies are not allowed. The time complexity of the algorithm is O(V + E), where V is the number of vertices, and E is the number of edges. It finds applications in task scheduling, dependency resolution, and compiler optimization.</span></p><a id="t.64a0a1fae94d65f662b304691e3cd0d9047d9dc5"></a><a id="t.9"></a><table class="c42 c55"><tr class="c32"><td class="c59" colspan="1" rowspan="1"><p class="c10"><span class="c3">import</span><span class="c0">&nbsp;java.util.*;<br><br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">TopologicalSort</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;V; </span><span class="c20">// Number of vertices</span><span class="c0"><br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c0">&nbsp;List&lt;Integer&gt; adjList[];<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c28 c21">TopologicalSort</span><span class="c1">(</span><span class="c3">int</span><span class="c1">&nbsp;v)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;V = v;<br> &nbsp; &nbsp; &nbsp; &nbsp;adjList = </span><span class="c3">new</span><span class="c0">&nbsp;LinkedList[v];<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; v; ++i)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;adjList[i] = </span><span class="c3">new</span><span class="c0">&nbsp;LinkedList&lt;&gt;();<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c20">// Function to add an edge to the graph</span><span class="c0"><br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">addEdge</span><span class="c1">(</span><span class="c3">int</span><span class="c1">&nbsp;v, </span><span class="c3">int</span><span class="c1">&nbsp;w)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;adjList[v].add(w);<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c20">// Recursive function to perform topological sort</span><span class="c0"><br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">topologicalSortUtil</span><span class="c1">(</span><span class="c3">int</span><span class="c1">&nbsp;v, </span><span class="c3">boolean</span><span class="c1">&nbsp;visited[], Stack&lt;Integer&gt; stack)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;visited[v] = </span><span class="c3">true</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(Integer neighbor : adjList[v]) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(!visited[neighbor])<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;topologicalSortUtil(neighbor, visited, stack);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;stack.push(v);<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c20">// Function to perform topological sort</span><span class="c0"><br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">topologicalSort</span><span class="c1">()</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Stack&lt;Integer&gt; stack = </span><span class="c3">new</span><span class="c0">&nbsp;Stack&lt;&gt;();<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">boolean</span><span class="c0">&nbsp;visited[] = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">boolean</span><span class="c0">[V];<br> &nbsp; &nbsp; &nbsp; &nbsp;Arrays.fill(visited, </span><span class="c3">false</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; V; ++i) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(!visited[i])<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;topologicalSortUtil(i, visited, stack);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20">// Print the topological order</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Topological Sort:&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c0">&nbsp;(!stack.isEmpty())<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(stack.pop() + </span><span class="c5">&quot; &quot;</span><span class="c0">);<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c1">(String args[])</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Scanner scanner = </span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.in);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20">// Taking input for the number of vertices</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(</span><span class="c5">&quot;Enter the number of vertices: &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;V = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp;TopologicalSort g = </span><span class="c3">new</span><span class="c0">&nbsp;TopologicalSort(V);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20">// Taking input for the adjacency matrix</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Enter the adjacency matrix:&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; V; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c0">; j &lt; V; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(scanner.nextInt() == </span><span class="c1">1</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;g.addEdge(i, j);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;g.topologicalSort();<br> &nbsp; &nbsp; &nbsp; &nbsp;scanner.close();<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c31 c27 c25"><span class="c7 c12"></span></p><p class="c6"><span class="c82 c21 c110">Output:</span></p><a id="t.42b4de3264229e5a365ff11e3ac7131b011105bd"></a><a id="t.10"></a><table class="c42 c43"><tr class="c32"><td class="c9" colspan="1" rowspan="1"><p class="c10"><span class="c0">Enter the number of vertices: </span><span class="c1">4</span><span class="c0"><br>Enter the adjacency matrix:<br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br>Topological Sort:<br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">2</span><span class="c0">&nbsp;</span><span class="c1">3</span></p></td></tr></table><p class="c31 c27 c25"><span class="c7 c12"></span></p><p class="c31 c27 c25"><span class="c7 c12"></span></p><p class="c31 c27 c25"><span class="c7 c12"></span></p><p class="c31 c27 c25"><span class="c7 c12"></span></p><p class="c31 c25"><span class="c2">6. Compute the Transitive closure of a given directed graph using Warshall&#39;s Algorithm. </span></p><p class="c31 c25"><span class="c7 c12">Warshall&#39;s Algorithm, also known as the Floyd-Warshall Algorithm, is used for finding the transitive closure of a directed graph. It computes the shortest paths between all pairs of vertices in a graph, taking into account both direct and indirect paths. The algorithm utilises dynamic programming and iteratively updates the shortest path matrix. It works for both positive and negative edge weights but does not handle negative cycles. The time complexity of Warshall&#39;s Algorithm is O(V^3), where V is the number of vertices. It is particularly useful for scenarios like network routing and determining reachability in a directed graph.</span></p><a id="t.0d560c1dbed9a4dc041c48ea97a092349255e799"></a><a id="t.11"></a><table class="c42 c43"><tr class="c32"><td class="c9" colspan="1" rowspan="1"><p class="c10"><span class="c0">import java.util.Scanner;<br><br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">Warshall_Transitive_Closure</span><span class="c0">&nbsp;{<br> &nbsp; </span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c0">(</span><span class="c1">String[] args</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; Scanner scanner = </span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.</span><span class="c3">in</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; System.</span><span class="c3">out</span><span class="c0">.print(</span><span class="c5">&quot;Enter the number of vertices: &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;vertices = scanner.nextInt();<br><br> &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">[][] adj = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[vertices][vertices];<br><br> &nbsp; &nbsp; &nbsp; System.</span><span class="c3">out</span><span class="c0">.println(</span><span class="c5">&quot;Enter the adj matrix: &quot;</span><span class="c0">);<br><br> &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; vertices; i++){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c0">; j &lt; vertices; j++){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; adj[i][j] = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; }<br><br> &nbsp; &nbsp; &nbsp; </span><span class="c20">/* O(N^3) -&gt; Time complexity */</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">(</span><span class="c3">int</span><span class="c0">&nbsp;k = </span><span class="c1">0</span><span class="c0">; k &lt; vertices; k++){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">[][] temp = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[vertices][vertices];<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; vertices; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c0">; j &lt; vertices; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp[i][j] = adj[i][j] | (adj[i][k] &amp; adj[k][j]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c20">// Update the original matrix with the temporary matrix</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; vertices; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c7 c0">; j &lt; vertices; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; adj[i][j] = temp[i][j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; }<br><br> &nbsp; &nbsp; &nbsp; </span></p><p class="c8"><span class="c7 c0"></span></p><p class="c8"><span class="c7 c0"></span></p><p class="c8"><span class="c7 c0"></span></p><p class="c8"><span class="c7 c0"></span></p><p class="c10"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp;System.</span><span class="c3">out</span><span class="c0">.println(</span><span class="c5">&quot;The transitive closure is below: &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; vertices; i++){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c0">; j &lt; vertices; j++){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.</span><span class="c3">out</span><span class="c0">.print(adj[i][j] + </span><span class="c5">&quot; &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.</span><span class="c3">out</span><span class="c0">.println();<br> &nbsp; &nbsp; &nbsp; }<br><br> &nbsp; }<br>}</span></p></td></tr></table><p class="c31 c27 c25"><span class="c7 c12"></span></p><p class="c31 c27 c25"><span class="c15"></span></p><p class="c31 c27 c25"><span class="c15"></span></p><p class="c31 c27 c25"><span class="c15"></span></p><p class="c31 c25"><span class="c33 c21">Output:</span></p><a id="t.13aaa6b2568184bb21c6198a419e1e653beaaabe"></a><a id="t.12"></a><table class="c30"><tr class="c32"><td class="c11" colspan="1" rowspan="1"><p class="c10"><span class="c0">Enter the number of vertices: <br>Enter the adj </span><span class="c28 c21">matrix</span><span class="c0">&nbsp;</span><span class="c1">(0 </span><span class="c3">for</span><span class="c1">&nbsp;no edge, 1 </span><span class="c3">for</span><span class="c1">&nbsp;edge)</span><span class="c0">:<br>0 1 0 1<br>0 0 1 0<br>0 0 0 1<br>0 0 0 0<br></span><span class="c7 c5">The transitive closure is below:</span></p><p class="c10"><span class="c0">1 1 1 1 <br>0 0 1 1 <br>0 0 0 1 <br>0 0 0 0</span></p></td></tr></table><p class="c31 c27 c25"><span class="c7 c23 c21"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c23 c21"></span></p><p class="c19"><span class="c7 c23 c21">7. Sort a given set of elements using the Heap sort method and determine the time required to sort the elements. Repeat the experiment for different values of n, the number of elements in the list to be sorted and plot a graph of the time taken versus number of elements.</span></p><p class="c8 c25"><span class="c7 c23 c21"></span></p><p class="c19"><span class="c7 c12">Heap Sort is a comparison-based sorting algorithm that builds a max-heap from the given array, then repeatedly extracts the maximum element (root of the heap) and swaps it with the last element. The heap size is reduced, and the heap property is maintained through the heapify operation. This process continues until the entire array is sorted. The algorithm has a time complexity of O(n log n), making it efficient for large datasets.</span></p><p class="c6 c27"><span class="c7 c106"></span></p><a id="t.37a2ec4c114b6e33902171f9608254bb6545094c"></a><a id="t.13"></a><table class="c42 c47"><tr class="c32"><td class="c62" colspan="1" rowspan="1"><p class="c10"><span class="c0">import java.util.*;<br><br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">HeapSort</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; </span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c0">(</span><span class="c1">String[] args</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp;Scanner scanner = </span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.</span><span class="c3">in</span><span class="c0">);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;System.</span><span class="c3">out</span><span class="c0">.print(</span><span class="c5">&quot;Enter the number of elements: &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;size = scanner.nextInt();<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">[] arr = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[size];<br><br> &nbsp; &nbsp; &nbsp; &nbsp;System.</span><span class="c3">out</span><span class="c0">.println(</span><span class="c5">&quot;Enter the elements:&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; size; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;arr[i] = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;System.</span><span class="c3">out</span><span class="c0">.println(</span><span class="c5">&quot;Original array: &quot;</span><span class="c0">&nbsp;+ Arrays.toString(arr));<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">long</span><span class="c0">&nbsp;startTime = System.nanoTime();<br> &nbsp; &nbsp; &nbsp; &nbsp;heapSort(arr);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">long</span><span class="c0">&nbsp;endTime = System.nanoTime();<br><br> &nbsp; &nbsp; &nbsp; &nbsp;System.</span><span class="c3">out</span><span class="c0">.println(</span><span class="c5">&quot;Sorted array: &quot;</span><span class="c0">&nbsp;+ Arrays.toString(arr));<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">long</span><span class="c0">&nbsp;duration = endTime - startTime;<br> &nbsp; &nbsp; &nbsp; &nbsp;System.</span><span class="c3">out</span><span class="c0">.println(</span><span class="c5">&quot;Time taken for sorting: &quot;</span><span class="c0">&nbsp;+ duration + </span><span class="c5">&quot; nanoseconds&quot;</span><span class="c0">);<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">heapSort</span><span class="c0">(</span><span class="c3">int</span><span class="c1">[] arr</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;n = arr.length;<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20">// Build heap (rearrange array)</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = n / </span><span class="c1">2</span><span class="c0">&nbsp;- </span><span class="c1">1</span><span class="c0">; i &gt;= </span><span class="c1">0</span><span class="c0">; i--) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;heapify(arr, n, i);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20">// One by one extract an element from the heap</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = n - </span><span class="c1">1</span><span class="c0">; i &gt; </span><span class="c1">0</span><span class="c0">; i--) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20">// Move current root to the end</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;temp = arr[</span><span class="c1">0</span><span class="c0">];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;arr[</span><span class="c1">0</span><span class="c0">] = arr[i];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;arr[i] = temp;<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20">// Call max heapify on the reduced heap</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;heapify(arr, i, </span><span class="c1">0</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">heapify</span><span class="c0">(</span><span class="c3">int</span><span class="c1">[] arr, </span><span class="c3">int</span><span class="c1">&nbsp;n, </span><span class="c3">int</span><span class="c1">&nbsp;i</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;largest = i; </span><span class="c20">// Initialize largest as root</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;left = </span><span class="c1">2</span><span class="c0">&nbsp;* i + </span><span class="c1">1</span><span class="c0">; </span><span class="c20">// left = 2*i + 1</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;right = </span><span class="c1">2</span><span class="c0">&nbsp;* i + </span><span class="c1">2</span><span class="c0">; </span><span class="c20">// right = 2*i + 2</span><span class="c0"><br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20">// If left child is larger than root</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;largest = left;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20">// If right child is larger than largest so far</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;largest = right;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20">// If largest is not root</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(largest != i) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;swap = arr[i];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;arr[i] = arr[largest];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;arr[largest] = swap;<br><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c20">// Recursively heapify the affected sub-tree</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;heapify(arr, n, largest);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br>}</span></p></td></tr><tr class="c32"><td class="c62" colspan="1" rowspan="1"><p class="c8"><span class="c7 c0"></span></p></td></tr></table><p class="c31 c27 c25"><span class="c7 c12"></span></p><p class="c31 c27 c25"><span class="c15"></span></p><p class="c31 c27 c25"><span class="c15"></span></p><p class="c31 c27 c25"><span class="c15"></span></p><p class="c31 c25"><span class="c33 c21">Output:</span></p><a id="t.376322520e247a8df42fa67fee86ae83d6a85357"></a><a id="t.14"></a><table class="c42 c25"><tr class="c32"><td class="c93" colspan="1" rowspan="1"><p class="c10"><span class="c0">Enter the number of </span><span class="c5">elements:</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0"><br>Enter the </span><span class="c5">elements:</span><span class="c0"><br></span><span class="c1">12</span><span class="c0">&nbsp;</span><span class="c1">11</span><span class="c0">&nbsp;</span><span class="c1">13</span><span class="c0">&nbsp;</span><span class="c1">5</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">7</span><span class="c0"><br>Original </span><span class="c5">array:</span><span class="c0">&nbsp;[</span><span class="c1">12</span><span class="c0">, </span><span class="c1">11</span><span class="c0">, </span><span class="c1">13</span><span class="c0">, </span><span class="c1">5</span><span class="c0">, </span><span class="c1">6</span><span class="c0">, </span><span class="c1">7</span><span class="c0">]<br>Sorted </span><span class="c5">array:</span><span class="c0">&nbsp;[</span><span class="c1">5</span><span class="c0">, </span><span class="c1">6</span><span class="c0">, </span><span class="c1">7</span><span class="c0">, </span><span class="c1">11</span><span class="c0">, </span><span class="c1">12</span><span class="c0">, </span><span class="c1">13</span><span class="c0">]<br>Time taken </span><span class="c3">for</span><span class="c0">&nbsp;</span><span class="c5">sorting:</span><span class="c0">&nbsp;</span><span class="c1">13594</span><span class="c0">&nbsp;nanoseconds</span></p></td></tr></table><p class="c31 c27 c25"><span class="c7 c12"></span></p><p class="c31 c27 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c31 c25"><span class="c13">Graph: (input size N - Number of elements in array v/s Time (in seconds)</span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c31 c25"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 600.00px; height: 399.00px;"><img alt="" src="images/image5.png" style="width: 600.00px; height: 399.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c31 c27 c25"><span class="c13"></span></p><p class="c31 c27 c25"><span class="c13"></span></p><p class="c31 c27 c25"><span class="c13"></span></p><p class="c31 c27 c25"><span class="c13"></span></p><p class="c31 c25"><span class="c7 c23 c21">8. Search for a pattern string in a given text using Horspool String Matching algorithm</span></p><p class="c10 c25"><span>Horspool String Matching algorithm is a technique used to efficiently search for a pattern string within a given text . It operates by pre-computing a shift table based on characters in the pattern to determine the maximum possible shift when a mismatch occurs during the search process. This shift table helps in shifting unnecessary comparisons , optimising the search </span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><a id="t.36e648098bb4a4f1a36b34b86ccdf386d314469a"></a><a id="t.15"></a><table class="c42 c75"><tr class="c121"><td class="c61" colspan="1" rowspan="1"><p class="c10"><span class="c3">import</span><span class="c0">&nbsp;java.util.Scanner;<br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">HorspoolStringMatching</span><span class="c0">&nbsp;{<br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[] shiftTable(String pattern) {<br><br></span><span class="c3">int</span><span class="c0">[] table = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[</span><span class="c1">256</span><span class="c0">];<br></span><span class="c3">int</span><span class="c0">&nbsp;m = pattern.length();<br></span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; </span><span class="c1">256</span><span class="c0">; i++) {<br> table[i] = m;<br>}<br></span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; m - </span><span class="c1">1</span><span class="c0">; i++) {<br> table[pattern.charAt(i)] = m - </span><span class="c1">1</span><span class="c0">&nbsp;- i;<br>}<br></span><span class="c3">return</span><span class="c0">&nbsp;table;<br> </span><span class="c3">int</span><span class="c0">&nbsp;i = m - </span><span class="c1">1</span><span class="c0">; </span><span class="c3">while</span><span class="c0">&nbsp;(i &lt; n) {<br></span><span class="c3">int</span><span class="c0">&nbsp;k = </span><span class="c1">0</span><span class="c0">;<br></span><span class="c3">while</span><span class="c0">&nbsp;(k &lt; m &amp;&amp; pattern.charAt(m - </span><span class="c1">1</span><span class="c0">&nbsp;- k) == text.charAt(i - k)) {<br>K++;<br> }<br></span><span class="c3">if</span><span class="c0">&nbsp;(k == m) {<br></span><span class="c3">return</span><span class="c0">&nbsp;i - m + </span><span class="c1">1</span><span class="c0">; </span><span class="c20">// Pattern found at index i - m + 1</span><span class="c0"><br>} </span><span class="c3">else</span><span class="c0">&nbsp;{<br>i += table[text.charAt(i)];<br>}<br> }<br></span><span class="c3">return</span><span class="c0">&nbsp;-</span><span class="c1">1</span><span class="c0">; </span><span class="c20">// Pattern not found</span><span class="c0"><br> }<br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c1">(String[] args)</span><span class="c0"><br> { <br>Scanner scanner = </span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.in);<br>System.out.print(</span><span class="c5">&quot;Enter the text: &quot;</span><span class="c0">); String text = scanner.nextLine();<br>System.out.print(</span><span class="c5">&quot;Enter the pattern to search for: &quot;</span><span class="c0">); <br>String pattern = scanner.nextLine();<br></span><span class="c3">long</span><span class="c0">&nbsp;startTime = System.nanoTime();<br></span><span class="c3">int</span><span class="c0">&nbsp;index = horspoolSearch(text, pattern);<br> </span><span class="c3">long</span><span class="c0">&nbsp;endTime = System.nanoTime();<br></span><span class="c3">if</span><span class="c0">&nbsp;(index != -</span><span class="c1">1</span><span class="c0">) <br>{<br>System.out.println(</span><span class="c5">&quot;Pattern found at index: &quot;</span><span class="c0">&nbsp;+ index);<br>}<br> </span><span class="c3">else</span><span class="c0">&nbsp;{<br>System.out.println(</span><span class="c5">&quot;Pattern not found.&quot;</span><span class="c0">);<br>}<br></span><span class="c3">double</span><span class="c0">&nbsp;timeElapsed = (endTime - startTime) / </span><span class="c1">1e6</span><span class="c0">; </span><span class="c20">// Convert nanoseconds to milliseconds</span><span class="c0"><br>System.out.println(</span><span class="c5">&quot;Time complexity: &quot;</span><span class="c0">&nbsp;+ timeElapsed + </span><span class="c5">&quot; milliseconds&quot;</span><span class="c7 c0">);<br>scanner.close(); <br>} </span></p></td></tr></table><p class="c8 c25"><span class="c2"></span></p><p class="c31 c27 c25"><span class="c2"></span></p><p class="c31 c25"><span class="c21 c33">Output: </span></p><a id="t.332f24a91fa4bc16ef9b4b46ea549195b81dddb1"></a><a id="t.16"></a><table class="c30"><tr class="c32"><td class="c65" colspan="1" rowspan="1"><p class="c10"><span class="c0">Enter the text: hello my name is priyanka<br>Enter the pattern to search </span><span class="c3">for</span><span class="c0">: priyanka<br>Pattern found at index: </span><span class="c1">17</span><span class="c0"><br>Time complexity: </span><span class="c1">0.0322</span><span class="c7 c0">&nbsp;milliseconds<br></span></p></td></tr></table><p class="c31 c27 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c10 c25"><span class="c2">9. Implement 0/1 Knapsack Problem using Dynamic Programming</span></p><p class="c8 c25"><span class="c2"></span></p><p class="c19"><span>The 0/1 Knapsack Problem is a fundamental optimization challenge addressed through dynamic programming. In this problem, a set of items, each with a specific weight and value, must be selectively included in a knapsack with a given capacity to maximise the total value. The &quot;0/1&quot; aspect denotes the binary decision for each item&mdash;either it is entirely included or excluded. Dynamic programming offers an efficient solution strategy, involving the creation of a table to store optimal solutions for subproblems. By systematically filling this table, the algorithm builds up to the optimal solution, avoiding redundant computations and showcasing the versatility of dynamic programming in solving real-world resource allocation and optimization dilemmas.</span></p><a id="t.0539a8d78e6c3da25e277d06a9eed551b6241ac7"></a><a id="t.17"></a><table class="c42 c25"><tr class="c32"></tr></table><p class="c8"><span class="c7 c12"></span></p><a id="t.60b1161904c765750ff7d1d9cf8c45d69ed5a6fa"></a><a id="t.18"></a><table class="c42 c47"><tr class="c32"><td class="c68" colspan="1" rowspan="1"><p class="c116"><span class="c106">&nbsp;</span><span class="c0">import java.util.Scanner;<br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">KnapsackDP</span><span class="c0">&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br> &nbsp; &nbsp; </span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;</span><span class="c28 c21">knapsack</span><span class="c0">(</span><span class="c3">int</span><span class="c1">[] weights, </span><span class="c3">int</span><span class="c1">[] values, </span><span class="c3">int</span><span class="c1">&nbsp;capacity</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;n = weights.length;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">[][] dp = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[n + </span><span class="c1">1</span><span class="c0">][capacity + </span><span class="c1">1</span><span class="c0">];<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt;= n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;w = </span><span class="c1">0</span><span class="c0">; w &lt;= capacity; w++) {<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(i == </span><span class="c1">0</span><span class="c0">&nbsp;|| w == </span><span class="c1">0</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp;dp[i][w] = </span><span class="c1">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;} <br> &nbsp; &nbsp; &nbsp; </span><span class="c3">else</span><span class="c0">&nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(weights[i - </span><span class="c1">1</span><span class="c0">] &lt;= w) {<br> &nbsp; &nbsp; &nbsp; dp[i][w] = Math.max(values[i - </span><span class="c1">1</span><span class="c0">] + dp[i - </span><span class="c1">1</span><span class="c0">][w - &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; . &nbsp; &nbsp; &nbsp;dp[i - </span><span class="c1">1</span><span class="c7 c0">][w]); &nbsp; &nbsp; &nbsp;</span></p><p class="c116"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; } </span><span class="c3">else</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;dp[i][w] = dp[i - </span><span class="c1">1</span><span class="c0">][w];<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;displayMatrix(dp);<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">return</span><span class="c0">&nbsp;dp[n][capacity];<br> &nbsp; &nbsp; &nbsp; }<br><br> &nbsp; &nbsp; &nbsp; </span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">displayMatrix</span><span class="c0">(</span><span class="c3">int</span><span class="c1">[][] matrix</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; matrix.length; i++) {<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c0">; j &lt; matrix[i].length; j++) {<br> &nbsp; &nbsp; &nbsp; System.</span><span class="c3">out</span><span class="c0">.print(matrix[i][j] + </span><span class="c5">&quot; &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.</span><span class="c3">out</span><span class="c0">.println();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; <br> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c0">(</span><span class="c1">String[] args</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scanner scanner = </span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.</span><span class="c3">in</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.</span><span class="c3">out</span><span class="c0">.print(</span><span class="c5">&quot;Enter the number of items: &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;n = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">[] weights = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[n];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">[] values = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[n];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.</span><span class="c3">out</span><span class="c0">.println(</span><span class="c5">&quot;Enter the weights of the items:&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;weights[i] = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.</span><span class="c3">out</span><span class="c0">.println(</span><span class="c5">&quot;Enter the values of the items:&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;values[i] = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.</span><span class="c3">out</span><span class="c0">.print(</span><span class="c5">&quot;Enter the knapsack capacity: &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;capacity = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.</span><span class="c3">out</span><span class="c0">.println(</span><span class="c5">&quot;Dynamic Programming Matrix:&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;maxValue = knapsack(weights, values, capacity);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.</span><span class="c3">out</span><span class="c0">.println(</span><span class="c5">&quot;Maximum value: &quot;</span><span class="c0">&nbsp;+ maxValue);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanner.close();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br></span></p></td></tr></table><p class="c8"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c82 c88 c23 c21"></span></p><p class="c8 c25"><span class="c82 c23 c21 c88"></span></p><p class="c10 c25"><span class="c82 c88 c23 c21">Output:</span></p><p class="c8 c25"><span class="c7 c12"></span></p><a id="t.b11315b2a099179898a4cdbba97cd00f2a4ccb9c"></a><a id="t.19"></a><table class="c42 c25"><tr class="c32"><td class="c45" colspan="1" rowspan="1"><p class="c10"><span class="c0">Enter the number of items:</span><span class="c1">&nbsp;3 </span><span class="c0"><br>Enter the weights of the items:</span><span class="c1">&nbsp;1 </span><span class="c0">2</span><span class="c1">&nbsp;3 </span><span class="c0"><br>Enter the values of the items:</span><span class="c1">&nbsp;10 </span><span class="c0">12</span><span class="c1">&nbsp;14 </span><span class="c0"><br>Enter the knapsack capacity:</span><span class="c1">&nbsp;5 </span><span class="c0"><br>Dynamic Programming Matrix:<br></span><span class="c1">&nbsp;0 </span><span class="c0">0</span><span class="c1">&nbsp;0 </span><span class="c0">0</span><span class="c1">&nbsp;0 </span><span class="c0">0 <br>0</span><span class="c1">&nbsp;10 </span><span class="c0">10</span><span class="c1">&nbsp;10 </span><span class="c0">10 10<br></span><span class="c1">&nbsp;0 </span><span class="c0">10</span><span class="c1">&nbsp;12 </span><span class="c0">22</span><span class="c1">&nbsp;22 </span><span class="c0">22<br></span><span class="c1">&nbsp;0 </span><span class="c0">10</span><span class="c1">&nbsp;12 </span><span class="c0">22</span><span class="c1">&nbsp;24 </span><span class="c0">26 <br>Maximum value:</span><span class="c1">&nbsp;26 </span></p></td></tr></table><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c10 c25"><span class="c21 c51">10. Prim&#39;s algorithm. Implement the program in Java language.</span><span class="c7 c12">&nbsp;</span></p><p class="c8 c25"><span class="c7 c23 c21"></span></p><p class="c19"><span>Prim&#39;s algorithm is a fundamental algorithm in graph theory used for finding the minimum spanning tree of a connected, undirected graph with weighted edges. The algorithm begins by selecting an arbitrary node as the starting point and then iteratively grows the spanning tree by adding the shortest edge that connects a vertex in the tree to a vertex outside the tree. This process continues until all vertices are included in the spanning tree. The resulting tree has the minimum possible total edge weight among all spanning trees of the graph. Implementing Prim&#39;s algorithm in Java involves maintaining data structures like priority queues or min-heaps to efficiently select the minimum-weight edges at each step. The Java implementation should effectively represent the graph, manage the edges, and provide a clear and concise solution for computing the minimum spanning tree. Efficiently handling data structures and ensuring proper edge selection are crucial aspects of a successful implementation</span><span class="c7 c23 c21">.</span></p><p class="c19 c27"><span class="c7 c23 c21"></span></p><p class="c19 c27"><span class="c7 c23 c21"></span></p><a id="t.e9aded08bec7ff696a4ad7d897472b1744491050"></a><a id="t.20"></a><table class="c42 c43"><tr class="c32"><td class="c9" colspan="1" rowspan="1"><p class="c10"><span class="c3">import</span><span class="c0">&nbsp;java.util.Scanner;<br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">prims</span><span class="c0">&nbsp;{<br> &nbsp; </span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c1">(String[] args)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;w[][]=</span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[</span><span class="c1">10</span><span class="c0">][</span><span class="c1">10</span><span class="c0">];<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;n,i,j,s,k=</span><span class="c1">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;min;<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;sum=</span><span class="c1">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;u=</span><span class="c1">0</span><span class="c0">,v=</span><span class="c1">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;flag=</span><span class="c1">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;sol[]=</span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[</span><span class="c1">10</span><span class="c0">];<br> &nbsp; &nbsp; &nbsp; System.out.println(</span><span class="c5">&quot;Enter the number of vertices&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; Scanner sc=</span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.in);<br> &nbsp; &nbsp; &nbsp; n=sc.nextInt();<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">(i=</span><span class="c1">1</span><span class="c0">;i&lt;=n;i++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sol[i]=</span><span class="c1">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; System.out.println(</span><span class="c5">&quot;Enter the weighted graph&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">(i=</span><span class="c1">1</span><span class="c0">;i&lt;=n;i++)<br> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">(j=</span><span class="c1">1</span><span class="c0">;j&lt;=n;j++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;w[i][j]=sc.nextInt();<br> &nbsp; &nbsp; &nbsp; System.out.println(</span><span class="c5">&quot;Enter the source vertex&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; s=sc.nextInt();<br> &nbsp; &nbsp; &nbsp; sol[s]=</span><span class="c1">1</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; k=</span><span class="c1">1</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">while</span><span class="c0">&nbsp;(k&lt;=n-</span><span class="c1">1</span><span class="c0">)<br> &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; min=</span><span class="c1">99</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">(i=</span><span class="c1">1</span><span class="c0">;i&lt;=n;i++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">(j=</span><span class="c1">1</span><span class="c0">;j&lt;=n;j++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">if</span><span class="c0">(sol[i]==</span><span class="c1">1</span><span class="c0">&amp;&amp;sol[j]==</span><span class="c1">0</span><span class="c0">)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">(i!=j &amp;&amp; min&gt;w[i][j])<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;min=w[i][j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;u=i;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;v=j;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sol[v]=</span><span class="c1">1</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sum=sum+min;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;k++;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(u+</span><span class="c5">&quot;-&gt;&quot;</span><span class="c0">+v+</span><span class="c5">&quot;=&quot;</span><span class="c0">+min);<br> &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">(i=</span><span class="c1">1</span><span class="c0">;i&lt;=n;i++)<br> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">if</span><span class="c0">(sol[i]==</span><span class="c1">0</span><span class="c0">)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flag=</span><span class="c1">1</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">if</span><span class="c0">(flag==</span><span class="c1">1</span><span class="c0">)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;No spanning tree&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">else</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(</span><span class="c5">&quot;The cost of minimum spanning tree is&quot;</span><span class="c0">+sum);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sc.close();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>}<br></span></p></td></tr></table><p class="c8 c86"><span class="c7 c12"></span></p><p class="c8 c86"><span class="c7 c12"></span></p><p class="c8 c86"><span class="c7 c12"></span></p><a id="t.c7f4b512896f3db26ce48cfac7b3d6becd88d95d"></a><a id="t.21"></a><table class="c42 c55"><tr class="c32"><td class="c59" colspan="1" rowspan="1"><p class="c10"><span class="c0">Output:<br>Enter the number of vertices<br></span><span class="c1">6</span><span class="c0"><br>Enter the weighted graph<br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">3</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">5</span><span class="c0"><br></span><span class="c1">3</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">4</span><span class="c0"><br></span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">4</span><span class="c0"><br></span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">8</span><span class="c0">&nbsp;</span><span class="c1">5</span><span class="c0"><br></span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">8</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">2</span><span class="c0"><br></span><span class="c1">5</span><span class="c0">&nbsp;</span><span class="c1">4</span><span class="c0">&nbsp;</span><span class="c1">4</span><span class="c0">&nbsp;</span><span class="c1">5</span><span class="c0">&nbsp;</span><span class="c1">2</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br>Enter the source vertex<br></span><span class="c1">1</span><span class="c0"><br></span><span class="c1">1</span><span class="c0">-&gt;</span><span class="c1">2</span><span class="c0">=</span><span class="c1">3</span><span class="c0"><br></span><span class="c1">2</span><span class="c0">-&gt;</span><span class="c1">3</span><span class="c0">=</span><span class="c1">1</span><span class="c0"><br></span><span class="c1">2</span><span class="c0">-&gt;</span><span class="c1">6</span><span class="c0">=</span><span class="c1">4</span><span class="c0"><br></span><span class="c1">6</span><span class="c0">-&gt;</span><span class="c1">5</span><span class="c0">=</span><span class="c1">2</span><span class="c0"><br></span><span class="c1">6</span><span class="c0">-&gt;</span><span class="c1">4</span><span class="c0">=</span><span class="c1">5</span><span class="c0"><br>The cost of minimum spanning tree is15</span></p></td></tr></table><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c2"></span></p><p class="c10 c25"><span class="c2">11. Find Minimum Cost Spanning Tree of a given undirected graph using &nbsp;Kruskal&#39;s algorithm</span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c19"><span class="c7 c12">Kruskal&#39;s algorithm is a widely used method for finding the Minimum Cost Spanning Tree (MCST) of an undirected graph. The primary objective of this algorithm is to connect all vertices of the given graph with the minimum possible total edge weight, ensuring that a tree is formed without any cycles. The algorithm starts by sorting all the edges of the graph in ascending order based on their weights. It then iteratively selects the smallest edge that does not form a cycle when added to the growing spanning tree. This process continues until all vertices are included in the tree, resulting in an optimal solution that minimizes the overall edge weights. Kruskal&#39;s algorithm is efficient, particularly for sparse graphs, and its simplicity makes it a popular choice for solving minimum spanning tree problems in various applications, such as network design and optimization.</span></p><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><a id="t.6182d49e0541558c977ec5e888a1b763bfe5b841"></a><a id="t.22"></a><table class="c42 c25"><tr class="c32"><td class="c45" colspan="1" rowspan="1"><p class="c10"><span class="c3">import</span><span class="c0">&nbsp;java.util.Scanner;<br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">kruskal</span><span class="c0">&nbsp;{<br> &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;parent[]=</span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[</span><span class="c1">10</span><span class="c0">];<br> &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;</span><span class="c28 c21">find</span><span class="c1">(</span><span class="c3">int</span><span class="c1">&nbsp;m)</span><span class="c0">{<br> &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;p=m;<br> &nbsp; </span><span class="c3">while</span><span class="c0">(parent[p]!=</span><span class="c1">0</span><span class="c0">)<br> &nbsp; &nbsp; p=parent[p];<br> &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;p;<br> &nbsp; }<br> &nbsp; &nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">union</span><span class="c1">(</span><span class="c3">int</span><span class="c1">&nbsp;i,</span><span class="c3">int</span><span class="c1">&nbsp;j)</span><span class="c0"><br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">(i&lt;j)<br> &nbsp; &nbsp; &nbsp;parent[i]=j;<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">else</span><span class="c0"><br> &nbsp; &nbsp; &nbsp;parent[j]=i;<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">krkl</span><span class="c1">(</span><span class="c3">int</span><span class="c1">[][]a, </span><span class="c3">int</span><span class="c1">&nbsp;n)</span><span class="c0"><br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;u=</span><span class="c1">0</span><span class="c0">,v=</span><span class="c1">0</span><span class="c0">,min,k=</span><span class="c1">0</span><span class="c0">,i,j,sum=</span><span class="c1">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c0">(k&lt;n-</span><span class="c1">1</span><span class="c0">)<br> &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;min=</span><span class="c1">99</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">(i=</span><span class="c1">1</span><span class="c0">;i&lt;=n;i++)<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">(j=</span><span class="c1">1</span><span class="c0">;j&lt;=n;j++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">(a[i][j]&lt;min&amp;&amp;i!=j)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;min=a[i][j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;u=i;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;v=j;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} <br> &nbsp; &nbsp; &nbsp; &nbsp;i=find(u);<br> &nbsp; &nbsp; &nbsp; &nbsp;j=find(v);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">(i!=j)<br> &nbsp; &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;union(i,j);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;(&quot;</span><span class="c0">+u+</span><span class="c5">&quot;,&quot;</span><span class="c0">+v+</span><span class="c5">&quot;)&quot;</span><span class="c0">+</span><span class="c5">&quot;=&quot;</span><span class="c0">+a[u][v]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sum=sum+a[u][v];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;k++;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; a[u][v]=a[v][u]=</span><span class="c1">99</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;The cost of minimum spanning tree = &quot;</span><span class="c0">+sum);<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp; </span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c1">(String[] args)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;a[][]=</span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[</span><span class="c1">10</span><span class="c0">][</span><span class="c1">10</span><span class="c0">];<br> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;i,j;<br> &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(</span><span class="c5">&quot;Enter the number of vertices of the graph&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Scanner sc=</span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.in);<br> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">int</span><span class="c0">&nbsp;n;<br> &nbsp; &nbsp; &nbsp; &nbsp; n=sc.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Enter the wieghted matrix&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">(i=</span><span class="c1">1</span><span class="c0">;i&lt;=n;i++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">(j=</span><span class="c1">1</span><span class="c0">;j&lt;=n;j++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;a[i][j]=sc.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp;kruskal k=</span><span class="c3">new</span><span class="c0">&nbsp;kruskal();<br> &nbsp; &nbsp; &nbsp; &nbsp;k.krkl(a,n);<br> &nbsp; &nbsp; &nbsp; &nbsp;sc.close();<br> &nbsp; &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c8 c25"><span class="c7 c12"></span></p><p class="c8 c25"><span class="c7 c12"></span></p><a id="t.aeddfe4dacf2f270884a92e6108f8e4654c30c25"></a><a id="t.23"></a><table class="c42 c25"><tr class="c32"><td class="c45" colspan="1" rowspan="1"><p class="c10"><span class="c0">Output:<br>Enter the number of vertices of the graph<br></span><span class="c1">6</span><span class="c0"><br>Enter the wieghted matrix<br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">3</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">5</span><span class="c0"><br></span><span class="c1">3</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">4</span><span class="c0"><br></span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">4</span><span class="c0"><br></span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">8</span><span class="c0">&nbsp;</span><span class="c1">5</span><span class="c0"><br></span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">8</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">2</span><span class="c0"><br></span><span class="c1">5</span><span class="c0">&nbsp;</span><span class="c1">4</span><span class="c0">&nbsp;</span><span class="c1">4</span><span class="c0">&nbsp;</span><span class="c1">5</span><span class="c0">&nbsp;</span><span class="c1">2</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br>(</span><span class="c1">2</span><span class="c0">,</span><span class="c1">3</span><span class="c0">)=</span><span class="c1">1</span><span class="c0"><br>(</span><span class="c1">5</span><span class="c0">,</span><span class="c1">6</span><span class="c0">)=</span><span class="c1">2</span><span class="c0"><br>(</span><span class="c1">1</span><span class="c0">,</span><span class="c1">2</span><span class="c0">)=</span><span class="c1">3</span><span class="c0"><br>(</span><span class="c1">2</span><span class="c0">,</span><span class="c1">6</span><span class="c0">)=</span><span class="c1">4</span><span class="c0"><br>(</span><span class="c1">4</span><span class="c0">,</span><span class="c1">6</span><span class="c0">)=</span><span class="c1">5</span><span class="c0"><br>The cost of minimum spanning tree = </span><span class="c1">15</span></p></td></tr></table><p class="c8 c25"><span class="c7 c12"></span></p><p class="c10 c25"><span class="c2">12. From a given vertex in a weighted connected graph, find shortest paths to other vertices using Dijkstra&#39;s algorithm.</span></p><p class="c8 c25"><span class="c2"></span></p><p class="c19"><span class="c7 c12">In the context of graph theory, the problem statement revolves around employing Dijkstra&#39;s algorithm to determine the shortest paths from a specified starting vertex to all other vertices in a connected graph with weighted edges. Dijkstra&#39;s algorithm, a fundamental and widely used algorithm in the realm of computer science and network routing, efficiently calculates the minimum distance from the source vertex to every other vertex by iteratively exploring the neighbouring nodes and updating the distance values. The weighted connected graph signifies that each edge connecting the vertices possesses a numerical weight, representing the cost or distance between the linked vertices. The objective is to unveil the most optimal paths, considering the cumulative weights, from the given origin to all other vertices, thereby facilitating a comprehensive understanding of the shortest routes within the network.</span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><a id="t.02e7e77f2051a7363539fb2fa397da5c0f02c76e"></a><a id="t.24"></a><table class="c25 c42"><tr class="c32"><td class="c45" colspan="1" rowspan="1"><p class="c10"><span class="c3">import</span><span class="c0">&nbsp;java.util.Scanner;<br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">Dijkstra</span><span class="c0">&nbsp;{<br><br> &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;d[]=</span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[</span><span class="c1">10</span><span class="c0">];<br> &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;p[]=</span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[</span><span class="c1">10</span><span class="c0">];<br> &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;visited[]=</span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[</span><span class="c1">10</span><span class="c0">];<br> &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">dijk</span><span class="c1">(</span><span class="c3">int</span><span class="c1">[][]a, </span><span class="c3">int</span><span class="c1">&nbsp;s, </span><span class="c3">int</span><span class="c1">&nbsp;n)</span><span class="c0"><br> &nbsp;{<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;u=-</span><span class="c1">1</span><span class="c0">,v,i,j,min;<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">(v=</span><span class="c1">0</span><span class="c0">;v&lt;n;v++)<br> &nbsp; &nbsp; {<br> &nbsp; &nbsp; &nbsp; d[v]=</span><span class="c1">99</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; p[v]=-</span><span class="c1">1</span><span class="c0">;<br> &nbsp; &nbsp; } <br> &nbsp; &nbsp; d[s]=</span><span class="c1">0</span><span class="c0">;<br> &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">(i=</span><span class="c1">0</span><span class="c0">;i&lt;n;i++){<br> &nbsp; &nbsp; &nbsp; &nbsp; min=</span><span class="c1">99</span><span class="c0">;<br> &nbsp; &nbsp; </span><span class="c3">for</span><span class="c0">(j=</span><span class="c1">0</span><span class="c0">;j&lt;n;j++){<br> &nbsp; &nbsp; </span><span class="c3">if</span><span class="c0">(d[j]&lt;min&amp;&amp; visited[j]==</span><span class="c1">0</span><span class="c0">)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp;min=d[j];<br> &nbsp; &nbsp; &nbsp; u=j;<br> &nbsp; &nbsp;}<br> &nbsp;}<br> &nbsp; &nbsp;visited[u]=</span><span class="c1">1</span><span class="c0">;<br> &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">(v=</span><span class="c1">0</span><span class="c0">;v&lt;n;v++){<br> &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">((d[u]+a[u][v]&lt;d[v])&amp;&amp;(u!=v)&amp;&amp;visited[v]==</span><span class="c1">0</span><span class="c0">)<br> &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp;d[v]=d[u]+a[u][v];<br> &nbsp; &nbsp; &nbsp;p[v]=u;<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp;}<br> &nbsp; }<br> &nbsp;}<br> &nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">path</span><span class="c1">(</span><span class="c3">int</span><span class="c1">&nbsp;v,</span><span class="c3">int</span><span class="c1">&nbsp;s)</span><span class="c0"><br> &nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">(p[v]!=-</span><span class="c1">1</span><span class="c0">)<br> &nbsp; &nbsp;path(p[v],s);<br> &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">(v!=s)<br> &nbsp; &nbsp;System.out.print(</span><span class="c5">&quot;-&gt;&quot;</span><span class="c0">+v+</span><span class="c5">&quot; &quot;</span><span class="c0">);<br> &nbsp; }<br> &nbsp; </span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">display</span><span class="c1">(</span><span class="c3">int</span><span class="c1">&nbsp;s,</span><span class="c3">int</span><span class="c1">&nbsp;n)</span><span class="c0">{<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;i;<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">(i=</span><span class="c1">0</span><span class="c0">;i&lt;n;i++)<br> &nbsp; &nbsp; &nbsp;{<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">(i!=s){<br> &nbsp; &nbsp; &nbsp;System.out.print(s+</span><span class="c5">&quot; &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp;path(i,s);<br> &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">(i!=s)<br> &nbsp; &nbsp; &nbsp;System.out.print(</span><span class="c5">&quot;=&quot;</span><span class="c0">+d[i]+</span><span class="c5">&quot; &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp;System.out.println();<br> &nbsp; &nbsp; }<br> &nbsp; &nbsp;}<br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c1">(String[] args)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;a[][]=</span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[</span><span class="c1">10</span><span class="c0">][</span><span class="c1">10</span><span class="c0">];<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;i,j,n,s;<br> &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;enter the number of vertices&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp;Scanner sc = </span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.in);<br> &nbsp; &nbsp; &nbsp;n=sc.nextInt();<br> &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;enter the weighted matrix&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">(i=</span><span class="c1">0</span><span class="c0">;i&lt;n;i++)<br> &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">(j=</span><span class="c1">0</span><span class="c0">;j&lt;n;j++)<br> &nbsp; &nbsp; &nbsp;a[i][j]=sc.nextInt();<br> &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;enter the source vertex&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp;s=sc.nextInt();<br> &nbsp; &nbsp; &nbsp;Dijkstra tr=</span><span class="c3">new</span><span class="c0">&nbsp;Dijkstra();<br> &nbsp; &nbsp; &nbsp;tr.dijk(a,s,n);<br> &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;the shortest path between source&quot;</span><span class="c0">+s+</span><span class="c5">&quot;to remainingvertices &nbsp; &nbsp;are&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp;tr.display(s,n);<br> &nbsp; &nbsp; &nbsp;sc.close();<br> &nbsp; &nbsp; }<br> &nbsp; }</span></p></td></tr></table><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><a id="t.69c5ebac4224a5714012b5a7ac1a782d1da34f09"></a><a id="t.25"></a><table class="c42 c25"><tr class="c32"><td class="c45" colspan="1" rowspan="1"><p class="c10"><span class="c0">OUTPUT :<br>enter the number of vertices<br></span><span class="c1">5</span><span class="c0"><br>enter the weighted matrix<br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">3</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">7</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0"><br></span><span class="c1">3</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">4</span><span class="c0">&nbsp;</span><span class="c1">2</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0"><br></span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">4</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">5</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0"><br></span><span class="c1">5</span><span class="c0">&nbsp;</span><span class="c1">2</span><span class="c0">&nbsp;</span><span class="c1">5</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">4</span><span class="c0"><br></span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">99</span><span class="c0">&nbsp;</span><span class="c1">6</span><span class="c0">&nbsp;</span><span class="c1">4</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br>enter the source vertex<br></span><span class="c1">0</span><span class="c0"><br>the shortest path between source </span><span class="c1">0</span><span class="c0">&nbsp;remaining vertices are<br></span><span class="c1">0</span><span class="c0">&nbsp;-&gt;</span><span class="c1">1</span><span class="c0">&nbsp;=</span><span class="c1">3</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;-&gt;</span><span class="c1">1</span><span class="c0">&nbsp;-&gt;</span><span class="c1">2</span><span class="c0">&nbsp;=</span><span class="c1">7</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;-&gt;</span><span class="c1">1</span><span class="c0">&nbsp;-&gt;</span><span class="c1">3</span><span class="c0">&nbsp;=</span><span class="c1">5</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;-&gt;</span><span class="c1">1</span><span class="c0">&nbsp;-&gt;</span><span class="c1">3</span><span class="c0">&nbsp;-&gt;</span><span class="c1">4</span><span class="c0">&nbsp;=</span><span class="c1">9</span></p></td></tr></table><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19"><span class="c51 c21">13.</span><span class="c51">&nbsp;</span><span class="c2">Solve Travelling Sale Person Problem Using Dynamic Programming approach.</span></p><p class="c19"><span class="c7 c12">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p><p class="c19"><span class="c7 c12">The Traveling Salesman Problem (TSP) is a classic optimization challenge where the goal is to find the most efficient route that visits a set of cities exactly once and returns to the starting city. The objective is to minimize the total distance or cost of the journey. This problem is NP-hard, meaning there&#39;s no known polynomial-time solution for all cases. It has applications in logistics, transportation, and network optimization. Various algorithms, such as genetic algorithms and dynamic programming, are employed to find near-optimal solutions. TSP&#39;s computational complexity increases exponentially with the number of cities, making it a fundamental problem in combinatorial optimization. .</span></p><p class="c19 c27"><span class="c7 c12"></span></p><a id="t.99b2943e7e5e837a0544f39dd98c810060f5e223"></a><a id="t.26"></a><table class="c42 c54"><tr class="c32"><td class="c97" colspan="1" rowspan="1"><p class="c10"><span class="c3">import</span><span class="c0">&nbsp;java.util.Scanner;<br><br></span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">TSPExp</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;weight[][], n, tour[], finalCost;<br> &nbsp; &nbsp;</span><span class="c3">final</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;INF = </span><span class="c1">1000</span><span class="c0">;<br><br> &nbsp; &nbsp;TSPExp() {<br> &nbsp; &nbsp; &nbsp; &nbsp;Scanner s = </span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.in);<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Enter no. of nodes:=&gt;&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;n = s.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp;weight = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[n][n];<br> &nbsp; &nbsp; &nbsp; &nbsp;tour = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[n - </span><span class="c1">1</span><span class="c0">];<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c0">; j &lt; n; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(i != j) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(</span><span class="c5">&quot;Enter weight of &quot;</span><span class="c0">&nbsp;+ (i + </span><span class="c1">1</span><span class="c0">) + </span><span class="c5">&quot; to &quot;</span><span class="c0">&nbsp;+ (j + </span><span class="c1">1</span><span class="c0">) + </span><span class="c5">&quot;:=&gt;&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;weight[i][j] = s.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Starting node assumed to be node 1.&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;eval();<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;</span><span class="c28 c21">COST</span><span class="c1">(</span><span class="c3">int</span><span class="c1">&nbsp;currentNode, </span><span class="c3">int</span><span class="c1">&nbsp;inputSet[], </span><span class="c3">int</span><span class="c1">&nbsp;setSize)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(setSize == </span><span class="c1">0</span><span class="c0">)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;weight[currentNode][</span><span class="c1">0</span><span class="c0">];<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;min = INF;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;setToBePassedOnToNextCallOfCOST[] = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[n - </span><span class="c1">1</span><span class="c0">];<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; setSize; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;k = </span><span class="c1">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c0">; j &lt; setSize; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(inputSet[i] != inputSet[j])<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;setToBePassedOnToNextCallOfCOST[k++] = inputSet[j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;temp = COST(inputSet[i], setToBePassedOnToNextCallOfCOST, setSize - </span><span class="c1">1</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;((weight[currentNode][inputSet[i]] + temp) &lt; min) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;min = weight[currentNode][inputSet[i]] + temp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;min;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;</span><span class="c28 c21">MIN</span><span class="c1">(</span><span class="c3">int</span><span class="c1">&nbsp;currentNode, </span><span class="c3">int</span><span class="c1">&nbsp;inputSet[], </span><span class="c3">int</span><span class="c1">&nbsp;setSize)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(setSize == </span><span class="c1">0</span><span class="c0">)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;weight[currentNode][</span><span class="c1">0</span><span class="c0">];<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;min = INF, minindex = </span><span class="c1">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;setToBePassedOnToNextCallOfCOST[] = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[n - </span><span class="c1">1</span><span class="c0">];<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; setSize; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;k = </span><span class="c1">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c0">; j &lt; setSize; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(inputSet[i] != inputSet[j])<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;setToBePassedOnToNextCallOfCOST[k++] = inputSet[j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;temp = COST(inputSet[i], setToBePassedOnToNextCallOfCOST, setSize - </span><span class="c1">1</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;((weight[currentNode][inputSet[i]] + temp) &lt; min) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;min = weight[currentNode][inputSet[i]] + temp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;minindex = inputSet[i];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;minindex;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">eval</span><span class="c1">()</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;dummySet[] = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[n - </span><span class="c1">1</span><span class="c0">];<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">1</span><span class="c0">; i &lt; n; i++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dummySet[i - </span><span class="c1">1</span><span class="c0">] = i;<br> &nbsp; &nbsp; &nbsp; &nbsp;finalCost = COST(</span><span class="c1">0</span><span class="c0">, dummySet, n - </span><span class="c1">1</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;constructTour();<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">constructTour</span><span class="c1">()</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;previousSet[] = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[n - </span><span class="c1">1</span><span class="c0">];<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;nextSet[] = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[n - </span><span class="c1">2</span><span class="c0">];<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">1</span><span class="c0">; i &lt; n; i++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;previousSet[i - </span><span class="c1">1</span><span class="c0">] = i;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;setSize = n - </span><span class="c1">1</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;tour[</span><span class="c1">0</span><span class="c0">] = MIN(</span><span class="c1">0</span><span class="c0">, previousSet, setSize);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">1</span><span class="c0">; i &lt; n - </span><span class="c1">1</span><span class="c0">; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;k = </span><span class="c1">0</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c0">; j &lt; setSize; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(tour[i - </span><span class="c1">1</span><span class="c0">] != previousSet[j])<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nextSet[k++] = previousSet[j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--setSize;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tour[i] = MIN(tour[i - </span><span class="c1">1</span><span class="c0">], nextSet, setSize);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c0">; j &lt; setSize; j++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;previousSet[j] = nextSet[j];<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;display();<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">display</span><span class="c1">()</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(</span><span class="c5">&quot;The tour is 1-&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; n - </span><span class="c1">1</span><span class="c0">; i++)<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print((tour[i] + </span><span class="c1">1</span><span class="c0">) + </span><span class="c5">&quot;-&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(</span><span class="c5">&quot;1&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println();<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;The final cost is &quot;</span><span class="c0">&nbsp;+ finalCost);<br> &nbsp; &nbsp;}<br>}<br><br></span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">TSP</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c1">(String args[])</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;TSPExp obj = </span><span class="c3">new</span><span class="c0">&nbsp;TSPExp();<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c19 c27"><span class="c18 c12"></span></p><p class="c19 c27"><span class="c18 c12"></span></p><p class="c19"><span class="c15">Output:</span></p><a id="t.a4ebe3b52d96fc416d1dc6c29d9252617cf46466"></a><a id="t.27"></a><table class="c42 c111"><tr class="c32"><td class="c64" colspan="1" rowspan="1"><p class="c10"><span class="c0">Enter no. of nodes:=&gt;<br></span><span class="c1">4</span><span class="c0"><br>Enter weight of </span><span class="c1">1</span><span class="c0">&nbsp;to </span><span class="c1">2</span><span class="c0">:=&gt;</span><span class="c1">2</span><span class="c0"><br>Enter weight of </span><span class="c1">1</span><span class="c0">&nbsp;to </span><span class="c1">3</span><span class="c0">:=&gt;</span><span class="c1">5</span><span class="c0"><br>Enter weight of </span><span class="c1">1</span><span class="c0">&nbsp;to </span><span class="c1">4</span><span class="c0">:=&gt;</span><span class="c1">7</span><span class="c0"><br>Enter weight of </span><span class="c1">2</span><span class="c0">&nbsp;to </span><span class="c1">1</span><span class="c0">:=&gt;</span><span class="c1">2</span><span class="c0"><br>Enter weight of </span><span class="c1">2</span><span class="c0">&nbsp;to </span><span class="c1">3</span><span class="c0">:=&gt;</span><span class="c1">8</span><span class="c0"><br>Enter weight of </span><span class="c1">2</span><span class="c0">&nbsp;to </span><span class="c1">4</span><span class="c0">:=&gt;</span><span class="c1">3</span><span class="c0"><br>Enter weight of </span><span class="c1">3</span><span class="c0">&nbsp;to </span><span class="c1">1</span><span class="c0">:=&gt;</span><span class="c1">5</span><span class="c0"><br>Enter weight of </span><span class="c1">3</span><span class="c0">&nbsp;to </span><span class="c1">2</span><span class="c0">:=&gt;</span><span class="c1">8</span><span class="c0"><br>Enter weight of </span><span class="c1">3</span><span class="c0">&nbsp;to </span><span class="c1">4</span><span class="c0">:=&gt;</span><span class="c1">1</span><span class="c0"><br>Enter weight of </span><span class="c1">4</span><span class="c0">&nbsp;to </span><span class="c1">1</span><span class="c0">:=&gt;</span><span class="c1">7</span><span class="c0"><br>Enter weight of </span><span class="c1">4</span><span class="c0">&nbsp;to </span><span class="c1">2</span><span class="c0">:=&gt;</span><span class="c1">3</span><span class="c0"><br>Enter weight of </span><span class="c1">4</span><span class="c0">&nbsp;to </span><span class="c1">3</span><span class="c0">:=&gt;</span><span class="c1">1</span><span class="c0"><br>Starting node assumed to be node </span><span class="c1">1</span><span class="c0">.<br>The tour is </span><span class="c1">1</span><span class="c0">-</span><span class="c1">2</span><span class="c0">-</span><span class="c1">4</span><span class="c0">-</span><span class="c1">3</span><span class="c0">-</span><span class="c1">1</span><span class="c0"><br>The </span><span class="c3">final</span><span class="c0">&nbsp;cost is </span><span class="c1">11</span></p></td></tr></table><p class="c19 c27"><span class="c18 c12"></span></p><p class="c19 c27"><span class="c18 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19"><span class="c2">14. Implement N Queen&rsquo;s Problem Using Back Tracking.</span></p><p class="c19"><span class="c7 c12">&nbsp; &nbsp; &nbsp; </span></p><p class="c19"><span class="c7 c12">The N Queen&#39;s Problem involves placing N chess queens on an N&times;N chessboard.</span></p><p class="c19"><span class="c7 c12">Backtracking is a technique to systematically explore all possibilities and backtrack when a solution is not feasible.Initialize an empty N&times;N chessboard.Start placing queens row by row, checking if the current placement violates any rules.If a violation is detected, backtrack to the previous row and explore a different position for the queen.Repeat this process until all queens are placed without violating any rules.</span></p><p class="c19"><span class="c7 c12">Explore different positions recursively, backtracking when necessary.The base case is when all queens are placed successfully.This ensures that all possible configurations are checked.</span></p><p class="c19"><span class="c7 c12">The final solution represents a valid arrangement of queens on the chessboard.</span></p><p class="c19 c27"><span class="c7 c12"></span></p><a id="t.9533f91dfe21ba13cacce251c4f7a04ebd962e8b"></a><a id="t.28"></a><table class="c42 c75"><tr class="c32"><td class="c102" colspan="1" rowspan="1"><p class="c10"><span class="c3">import</span><span class="c0">&nbsp;java.util.Scanner;<br><br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">NQueensBacktracking</span><span class="c0">&nbsp;{<br><br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">boolean</span><span class="c0">&nbsp;</span><span class="c28 c21">isSafe</span><span class="c1">(</span><span class="c3">int</span><span class="c1">[][] board, </span><span class="c3">int</span><span class="c1">&nbsp;row, </span><span class="c3">int</span><span class="c1">&nbsp;col, </span><span class="c3">int</span><span class="c1">&nbsp;N)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; col; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(board[row][i] == </span><span class="c1">1</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;</span><span class="c3">false</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = row, j = col; i &gt;= </span><span class="c1">0</span><span class="c0">&nbsp;&amp;&amp; j &gt;= </span><span class="c1">0</span><span class="c0">; i--, j--) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(board[i][j] == </span><span class="c1">1</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;</span><span class="c3">false</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = row, j = col; i &lt; N &amp;&amp; j &gt;= </span><span class="c1">0</span><span class="c0">; i++, j--) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(board[i][j] == </span><span class="c1">1</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;</span><span class="c3">false</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;</span><span class="c3">true</span><span class="c0">;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">private</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">boolean</span><span class="c0">&nbsp;</span><span class="c28 c21">solveNQueensUtil</span><span class="c1">(</span><span class="c3">int</span><span class="c1">[][] board, </span><span class="c3">int</span><span class="c1">&nbsp;col, </span><span class="c3">int</span><span class="c1">&nbsp;N)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(col &gt;= N) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;</span><span class="c3">true</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; N; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(isSafe(board, i, col, N)) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;board[i][col] = </span><span class="c1">1</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(solveNQueensUtil(board, col + </span><span class="c1">1</span><span class="c0">, N)) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;</span><span class="c3">true</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;board[i][col] = </span><span class="c1">0</span><span class="c0">; </span><span class="c20">// Backtrack</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;</span><span class="c3">false</span><span class="c0">;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">boolean</span><span class="c0">&nbsp;</span><span class="c28 c21">solveNQueens</span><span class="c1">(</span><span class="c3">int</span><span class="c1">&nbsp;N)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">[][] board = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[N][N];<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(!solveNQueensUtil(board, </span><span class="c1">0</span><span class="c0">, N)) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;</span><span class="c3">false</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;displayBoard(board, N);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;</span><span class="c3">true</span><span class="c0">;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">displayBoard</span><span class="c1">(</span><span class="c3">int</span><span class="c1">[][] board, </span><span class="c3">int</span><span class="c1">&nbsp;N)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; N; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">0</span><span class="c0">; j &lt; N; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(board[i][j] + </span><span class="c5">&quot; &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println();<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c1">(String[] args)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Scanner scanner = </span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.in);<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(</span><span class="c5">&quot;Enter the value of N: &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;N = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">long</span><span class="c0">&nbsp;startTime = System.nanoTime();<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">boolean</span><span class="c0">&nbsp;solutionExists = solveNQueens(N);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">long</span><span class="c0">&nbsp;endTime = System.nanoTime();<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(!solutionExists) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;No solution exists for N = &quot;</span><span class="c0">&nbsp;+ N);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">double</span><span class="c0">&nbsp;timeElapsed = (endTime - startTime) / </span><span class="c1">1e6</span><span class="c0">; </span><span class="c20">// Convert nanoseconds to milliseconds</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;\nTime complexity: &quot;</span><span class="c0">&nbsp;+ timeElapsed + </span><span class="c5">&quot; milliseconds&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;scanner.close();<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c15"></span></p><p class="c19"><span class="c15">OUTPUT:</span></p><a id="t.4390495e330348e60f443d7bd2a393ab19b13845"></a><a id="t.29"></a><table class="c42 c94"><tr class="c32"><td class="c109" colspan="1" rowspan="1"><p class="c10"><span class="c0">Enter the value of N: </span><span class="c1">4</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br></span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br>Time complexity: </span><span class="c1">13.266379</span><span class="c0">&nbsp;milliseconds<br>Enter the value of N: </span><span class="c1">8</span><span class="c0"><br></span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br></span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">1</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0">&nbsp;</span><span class="c1">0</span><span class="c0"><br>Time complexity: </span><span class="c1">16.839419</span><span class="c0">&nbsp;milliseconds</span></p></td></tr></table><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19"><span class="c7 c12">Program: Subset Problem (in next page)</span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19 c27"><span class="c2"></span></p><p class="c19"><span class="c2">15. Java program that reads inputs from the keyboard to solve the Subset Sum problem using dynamic programming and displays the time complexity, including finding and displaying the actual subsets that contribute to the sum</span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19"><span class="c7 c12">&nbsp;Dynamic programming is used to solve the Subset Sum Problem efficiently. The approach involves creating a two-dimensional array where each cell represents whether a specific sum can be achieved with a subset of the given numbers. The base case initialises the array with True for the target sum and False for others. Iterating through the array, each cell is filled based on the inclusion or exclusion of the current number. The final cell contains the solution, indicating if the target sum is reachable. This dynamic programming technique optimally avoids redundant calculations, providing a polynomial-time solution to the Subset Sum Problem.</span></p><p class="c19 c27"><span class="c7 c12"></span></p><a id="t.4252a145b81ca6ec0f434b55e68c00f913c0049f"></a><a id="t.30"></a><table class="c42 c43"><tr class="c32"><td class="c9" colspan="1" rowspan="1"><p class="c10"><span class="c3">import</span><span class="c0">&nbsp;java.util.ArrayList;<br></span><span class="c3">import</span><span class="c0">&nbsp;java.util.Scanner;<br><br></span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">class</span><span class="c0">&nbsp;</span><span class="c28 c21">SubsetSumDP</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">boolean</span><span class="c0">&nbsp;</span><span class="c28 c21">subsetSum</span><span class="c1">(</span><span class="c3">int</span><span class="c1">[] arr, </span><span class="c3">int</span><span class="c1">&nbsp;sum, ArrayList&lt;Integer&gt; subset)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;n = arr.length;<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">boolean</span><span class="c0">[][] dp = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">boolean</span><span class="c0">[n + </span><span class="c1">1</span><span class="c0">][sum + </span><span class="c1">1</span><span class="c0">];<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt;= n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i][</span><span class="c1">0</span><span class="c0">] = </span><span class="c3">true</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">1</span><span class="c0">; i &lt;= n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;j = </span><span class="c1">1</span><span class="c0">; j &lt;= sum; j++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(j &gt;= arr[i - </span><span class="c1">1</span><span class="c0">]) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = dp[i - </span><span class="c1">1</span><span class="c0">][j] || dp[i - </span><span class="c1">1</span><span class="c0">][j - arr[i - </span><span class="c1">1</span><span class="c0">]];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} </span><span class="c3">else</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i][j] = dp[i - </span><span class="c1">1</span><span class="c0">][j];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(!dp[n][sum]) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;</span><span class="c3">false</span><span class="c0">;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;i = n, j = sum;<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">while</span><span class="c0">&nbsp;(i &gt; </span><span class="c1">0</span><span class="c0">&nbsp;&amp;&amp; j &gt; </span><span class="c1">0</span><span class="c0">) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(dp[i][j] != dp[i - </span><span class="c1">1</span><span class="c0">][j]) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;subset.add(arr[i - </span><span class="c1">1</span><span class="c0">]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;j -= arr[i - </span><span class="c1">1</span><span class="c0">];<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;i--;<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">return</span><span class="c0">&nbsp;</span><span class="c3">true</span><span class="c0">;<br> &nbsp; &nbsp;}<br><br> &nbsp; &nbsp;</span><span class="c3">public</span><span class="c0">&nbsp;</span><span class="c3">static</span><span class="c0">&nbsp;</span><span class="c3">void</span><span class="c0">&nbsp;</span><span class="c28 c21">main</span><span class="c1">(String[] args)</span><span class="c0">&nbsp;{<br> &nbsp; &nbsp; &nbsp; &nbsp;Scanner scanner = </span><span class="c3">new</span><span class="c0">&nbsp;Scanner(System.in);<br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(</span><span class="c5">&quot;Enter the number of elements: &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;n = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">[] arr = </span><span class="c3">new</span><span class="c0">&nbsp;</span><span class="c3">int</span><span class="c0">[n];<br><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Enter the elements:&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">for</span><span class="c0">&nbsp;(</span><span class="c3">int</span><span class="c0">&nbsp;i = </span><span class="c1">0</span><span class="c0">; i &lt; n; i++) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;arr[i] = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.print(</span><span class="c5">&quot;Enter the target sum: &quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">int</span><span class="c0">&nbsp;sum = scanner.nextInt();<br> &nbsp; &nbsp; &nbsp; &nbsp;ArrayList&lt;Integer&gt; subset = </span><span class="c3">new</span><span class="c0">&nbsp;ArrayList&lt;&gt;();<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">long</span><span class="c0">&nbsp;startTime = System.nanoTime();<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">boolean</span><span class="c0">&nbsp;hasSubsetSum = subsetSum(arr, sum, subset);<br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">long</span><span class="c0">&nbsp;endTime = System.nanoTime();<br><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Subset sum exists: &quot;</span><span class="c0">&nbsp;+ hasSubsetSum);<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">if</span><span class="c0">&nbsp;(hasSubsetSum) {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Subset contributing to the sum: &quot;</span><span class="c0">&nbsp;+ subset);<br> &nbsp; &nbsp; &nbsp; &nbsp;}<br><br> &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">double</span><span class="c0">&nbsp;timeElapsed = (endTime - startTime) / </span><span class="c1">1e6</span><span class="c0">; </span><span class="c20">// Convert nanoseconds to milliseconds</span><span class="c0"><br> &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(</span><span class="c5">&quot;Time complexity: &quot;</span><span class="c0">&nbsp;+ timeElapsed + </span><span class="c5">&quot; milliseconds&quot;</span><span class="c0">);<br> &nbsp; &nbsp; &nbsp; &nbsp;scanner.close();<br> &nbsp; &nbsp;}<br>}</span></p></td></tr></table><p class="c19 c27"><span class="c15"></span></p><p class="c19 c27"><span class="c15"></span></p><p class="c19 c27"><span class="c15"></span></p><p class="c19 c27"><span class="c15"></span></p><p class="c19 c27"><span class="c15"></span></p><p class="c19"><span class="c15">OUTPUT</span></p><a id="t.1d7673c50ad7aa1138095232e4a84409278899b1"></a><a id="t.31"></a><table class="c42 c47"><tr class="c32"><td class="c62" colspan="1" rowspan="1"><p class="c10"><span class="c0">Enter the number of elements: </span><span class="c1">4</span><span class="c0"><br>Enter the elements:<br></span><span class="c1">1</span><span class="c0"><br></span><span class="c1">2</span><span class="c0"><br></span><span class="c1">3</span><span class="c0"><br></span><span class="c1">4</span><span class="c0"><br>Enter the target sum: </span><span class="c1">5</span><span class="c0"><br>Subset sum exists: </span><span class="c3">true</span><span class="c0"><br>Subset contributing to the sum: [</span><span class="c1">3</span><span class="c0">, </span><span class="c1">2</span><span class="c0">]<br>Time complexity: </span><span class="c1">0.1338</span><span class="c0">&nbsp;milliseconds</span></p></td></tr></table><p class="c19 c27"><span class="c7 c12"></span></p><p class="c19 c27"><span class="c7 c12"></span></p><p class="c25 c83"><span class="c21">End of the report.</span></p><div><p class="c8 c86"><span class="c7 c12"></span></p><p class="c10 c35"><span class="c12 c36">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p><p class="c10 c57"><span class="c78">&nbsp; &nbsp; &nbsp;</span><span class="c78">U03NM21T064023</span><span class="c95">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c7 c12">&nbsp; &nbsp; </span></p></div></body></html>
